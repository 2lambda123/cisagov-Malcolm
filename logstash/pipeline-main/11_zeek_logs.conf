########################
# zeek -> moloch session creation and enrichment
#
# see source.zeeklogs.js for the Moloch code that turns these into UI fields
#
# this monstrosity can be used to profile:
#   $ curl -XGET http://localhost:9600/_node/stats/pipelines | python -mjson.tool | grep -P '"(id|duration_in_millis)":' | sed "s/.*: //" | sed ':a;N;$!ba;s/",\n/ /g' | sed "s/[\",]//g" | awk -F " " '{printf("%s %s\n", $2, $1)}' | sort -n
#
# Copyright (c) 2019 Battelle Energy Alliance, LLC.  All rights reserved.
#######################

filter {

  if (([message] =~ /^\s*#/) or (![source])) {
    drop { id => "drop_zeek_invalid_logs" }
  }

  # tags may have been specified, like: conn(tagA,tagB,tagC).log, extract the log type (conn) and the tags (tagA,tagB,tagC)
  ruby {
    id => "ruby_zeek_source_extract"
                                                                  #↓Type     ↓Tags
    code => "
      if fileParts = event.get('[source]').split('/').last.match(/^(.*?)(?:\((.*)\))?\.log/i) then
        logType, tags = fileParts.captures
        event.set('[source]', logType) unless logType.nil?
        event.set('[@metadata][zeek_log_tags]', tags) unless tags.nil?
      end"
  }

  # report types we're going to ignore
  if (([source] == "reporter") or
      ([source] == "broker") or
      ([source] == "cluster") or
      ([source] == "capture_loss") or
      ([source] == "communication") or
      ([source] == "packet_filter") or
      ([source] == "stats") or
      ([source] == "stderr") or
      ([source] == "stdout") or
      ([source] == "loaded_scripts")) {
    drop { id => "drop_zeek_ignored_source" }
  }

  # remove some tags pulled from the filename we might not want
  if ([@metadata][zeek_log_tags]) {
    ruby {
      id => "ruby_zeek_prune_tags"
      code => "
        filenameTags = event.get('[@metadata][zeek_log_tags]').split(',')
        zeekFieldsTag = filenameTags.select { |str| str.start_with?('ZEEKFLDx') }
        if (zeekFieldsTag.size > 0) then
          zeekFieldsTags = zeekFieldsTag.first.split('x', 3)
          if (zeekFieldsTags.size == 3) then
            event.set('[@metadata][zeek_fields_bitmap_version]', zeekFieldsTags[1].to_i(16))
            event.set('[@metadata][zeek_fields_bitmap]', zeekFieldsTags[2].to_i(16))
          end
        end
        filenameTags.delete_if{|v| ((v == nil) or (v == '') or (v !~ /\D/) or (v =~ /\A\s*(ZEEKFLDx|autocarve)/i) or (v =~ /\A\s*(pcap|dmp|log|bro|zeek|tcpdump|netsniff|autozeek)s?\s*\z/i) or (v == event.get('[source]')))}
        event.set('[@metadata][zeek_log_tags]', filenameTags.uniq)
      "
      #
      #  ZEEKFLDx00x01FFFFFF
      #  |      |  └ bitmap of included fields within field list
      #  |      └ index into zeek-log-field-bitmap.py:ZEEK_LOG_FIELDS list indicating field configuration within differing Zeek versions
      #  └ indicates that the field list has been pre-processed by zeek-process-pcap.py
      #
      # when logstash-filter-dissect gets this implemented, we *may* not have to do this
      #   - see zeek-process-pcap.py for the format of the bitmap number
      #   - https://github.com/logstash-plugins/logstash-filter-dissect/issues/56
      #   - https://github.com/logstash-plugins/logstash-filter-dissect/issues/62
      #
      # todo: right now rather than using the bitmap intelligently to build the field list, I'm just looking for
      # known preconfigurations. look into doing it "smart".
      #
    }
    if ([@metadata][zeek_log_tags]) { mutate { id => "mutate_merge_zeek_log_tags"
                                                  merge => { "[tags]" => "[@metadata][zeek_log_tags]" } } }
  }

  # The Dissect is WAY faster than CSV, and quite a bit faster than mutate.split. However, it
  # is not as flexible when it comes to missing or extra columns
  # (See https://github.com/logstash-plugins/logstash-filter-dissect/issues/62)
  #
  # So, if the dissect filter fails, we're going to fall back to split-then-zip solution.
  # This should be a good tradeoff between performance (in the case where the Zeek logs
  # match what we think they should look like) and flexibility (when they don't).
  #
  # The one drawback is that if you make a change to the fields in dissect, make sure
  # you make the corresponding change in the ruby init code.

  if ([source] == "conn") {
    #############################################################################################################################
    # conn.log

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap conn.log field configuration version 0
      #
      # Todo: I need to just bite the bullet and code this up in a Ruby block rather than hardcoding values.
      #
      # vlan + mac + community_id:  0x3ffffff / 67108863
      # vlan + mac:                 0x1ffffff / 33554431
      # mac + community_id:         0x39fffff / 60817407
      # mac only:                   0x19fffff / 27262975
      # vlan + community_id:        0x27fffff / 41943039
      # vlan only:                   0x7fffff /  8388607
      # community_id only:           0x1fffff /  2097151
      # no custom fields:

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 67108863) {
          # conn.log has vlans + macs + community_id
          dissect {
            id => "dissect_zeek_conn_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 33554431) {
          # conn.log has vlans + macs
          dissect {
            id => "dissect_zeek_conn_with_vlan_and_mac_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 60817407) {
          # conn.log has macs + community_id
          dissect {
            id => "dissect_zeek_conn_with_mac_and_community_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 27262975) {
          # conn.log has macs
          dissect {
            id => "dissect_zeek_conn_with_mac_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][resp_l2_addr]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 41943039) {
          # conn.log has vlans + community_id
          dissect {
            id => "dissect_zeek_conn_with_vlan_and_community_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 8388607) {
          # conn.log has vlans
          dissect {
            id => "dissect_zeek_conn_with_vlan_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][vlan]}	%{[zeek_cols][inner_vlan]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 2097151) {
          # conn.log has community_id
          dissect {
            id => "dissect_zeek_conn_with_community_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}	%{[zeek_cols][community_id]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 2097151) {
          # conn.log has no custom fields
          dissect {
            id => "dissect_zeek_conn_with_minimal_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][duration]}	%{[zeek_cols][orig_bytes]}	%{[zeek_cols][resp_bytes]}	%{[zeek_cols][conn_state]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][local_resp]}	%{[zeek_cols][missed_bytes]}	%{[zeek_cols][history]}	%{[zeek_cols][orig_pkts]}	%{[zeek_cols][orig_ip_bytes]}	%{[zeek_cols][resp_pkts]}	%{[zeek_cols][resp_ip_bytes]}	%{[zeek_cols][tunnel_parents]}"
            }
          }

        } else {
          # who knows? the conn.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_conn_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the conn.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_conn_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the conn.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_conn_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_conn"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_conn"
        init => "$zeek_conn_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'service', 'duration', 'orig_bytes', 'resp_bytes', 'conn_state', 'local_orig', 'local_resp', 'missed_bytes', 'history', 'orig_pkts', 'orig_ip_bytes', 'resp_pkts', 'resp_ip_bytes', 'tunnel_parents', 'vlan', 'inner_vlan', 'orig_l2_addr', 'resp_l2_addr', 'community_id' ]"
        code => "event.set('[zeek_cols]', $zeek_conn_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_field_zeek_conn_segmentCnt"
      add_field => {
        "[segmentCnt]" => "1"
      }
    }

    dissect {
      id => "dissect_zeek_conn_convert_datatype_segmentCnt"
      convert_datatype => {
        "[segmentCnt]" => "int"
      }
    }

    if ([zeek_cols][orig_ip_bytes]) and ([zeek_cols][orig_ip_bytes] != '-') and ([zeek_cols][orig_ip_bytes] != '(empty)') and ([zeek_cols][orig_ip_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_srcBytes"
               add_field => { "[srcBytes]" => "%{[zeek_cols][orig_ip_bytes]}" } }
    }
    if ([zeek_cols][resp_ip_bytes]) and ([zeek_cols][resp_ip_bytes] != '-') and ([zeek_cols][resp_ip_bytes] != '(empty)') and ([zeek_cols][resp_ip_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_dstBytes"
               add_field => { "[dstBytes]" => "%{[zeek_cols][resp_ip_bytes]}" } }
    }
    if ([zeek_cols][orig_pkts]) and ([zeek_cols][orig_pkts] != '-') and ([zeek_cols][orig_pkts] != '(empty)') and ([zeek_cols][orig_pkts] != '') {
      mutate { id => "mutate_add_field_zeek_srcPackets"
               add_field => { "[srcPackets]" => "%{[zeek_cols][orig_pkts]}" } }
    }
    if ([zeek_cols][orig_bytes]) and ([zeek_cols][orig_bytes] != '-') and ([zeek_cols][orig_bytes] != '(empty)') and ([zeek_cols][orig_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_srcDataBytes"
               add_field => { "[srcDataBytes]" => "%{[zeek_cols][orig_bytes]}" } }
    }
    if ([zeek_cols][resp_pkts]) and ([zeek_cols][resp_pkts] != '-') and ([zeek_cols][resp_pkts] != '(empty)') and ([zeek_cols][resp_pkts] != '') {
      mutate { id => "mutate_add_field_zeek_dstPackets"
               add_field => { "[dstPackets]" => "%{[zeek_cols][resp_pkts]}" } }
    }
    if ([zeek_cols][resp_bytes]) and ([zeek_cols][resp_bytes] != '-') and ([zeek_cols][resp_bytes] != '(empty)') and ([zeek_cols][resp_bytes] != '') {
      mutate { id => "mutate_add_field_zeek_dstDataBytes"
               add_field => { "[dstDataBytes]" => "%{[zeek_cols][resp_bytes]}" } }
    }
    if ([zeek_cols][tunnel_parents]) and ([zeek_cols][tunnel_parents] != '(empty)') and ([zeek_cols][tunnel_parents] != '-') and ([zeek_cols][tunnel_parents] != '') {
      mutate { id => "mutate_split_zeek_tunnel_parents"
               split => { "[zeek_cols][tunnel_parents]" => "," } }
      mutate { id => "mutate_add_field_zeek_conn_rootId"
               add_field => { "[rootId]" => "%{[zeek_cols][tunnel_parents][0]}" } }
    }

  } else if ([source] == "bacnet") {
    #############################################################################################################################
    # bacnet.log
    # https://github.com/amzn/zeek-plugin-bacnet

    dissect {
      id => "dissect_zeek_bacnet"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][bvlc_function]}	%{[zeek_cols][bvlc_len]}	%{[zeek_cols][apdu_type]}	%{[zeek_cols][service_choice]}	%{[zeek_cols][data]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_bacnet"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_bacnet"
        init => "$zeek_bacnet_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'bvlc_function', 'bvlc_len', 'apdu_type', 'service_choice', 'data' ]"
        code => "event.set('[zeek_cols]', $zeek_bacnet_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_bacnet"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "bacnet"
      }
    }

  } else if ([source] == "cip") {
    #############################################################################################################################
    # cip.log
    # https://github.com/amzn/zeek-plugin-enip

    dissect {
      id => "dissect_zeek_cip"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][cip_service]}	%{[zeek_cols][status]}	%{[zeek_cols][cip_tags]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_cip"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_cip"
        init => "$zeek_cip_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'cip_service', 'status', 'cip_tags' ]"
        code => "event.set('[zeek_cols]', $zeek_cip_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_cip"
      add_field => {
        "[zeek_cols][service]" => "cip"
      }
    }

  } else if ([source] == "dce_rpc") {
    #############################################################################################################################
    # dce_rpc.log

    dissect {
      id => "dissect_zeek_dce_rpc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][rtt]}	%{[zeek_cols][named_pipe]}	%{[zeek_cols][endpoint]}	%{[zeek_cols][operation]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dce_rpc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dce_rpc"
        init => "$zeek_dce_rpc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'rtt', 'named_pipe', 'endpoint', 'operation' ]"
        code => "event.set('[zeek_cols]', $zeek_dce_rpc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dce_rpc"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "dce_rpc"
      }
    }

  } else if ([source] == "dhcp") {
    #############################################################################################################################
    # dhcp.log

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap dhcp.log field configuration version 0
      #
      # all fields: 0x000003FF / 1023
      #
      # bitmap dhcp.log field configuration version 1
      #
      # all fields: 0x00007FFF / 32767

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 1023) {
          dissect {
            id => "dissect_zeek_dhcp_0_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][assigned_ip]}	%{[zeek_cols][lease_time]}	%{[zeek_cols][trans_id]}"
            }
          }

        } else {
          # who knows? the dhcp.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_dhcp_0_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else if ([@metadata][zeek_fields_bitmap_version] == 1) {

        if ([@metadata][zeek_fields_bitmap] == 32767) {
          dissect {
            id => "dissect_zeek_dhcp_1_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uids]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][orig_l2_addr]}	%{[zeek_cols][host_name]}	%{[zeek_cols][client_fqdn]}	%{[zeek_cols][domain]}	%{[zeek_cols][requested_ip]}	%{[zeek_cols][assigned_ip]}	%{[zeek_cols][lease_time]}	%{[zeek_cols][client_message]}	%{[zeek_cols][server_message]}	%{[zeek_cols][msg_types]}	%{[zeek_cols][duration]}"
            }
          }

        } else {
          # who knows? the dhcp.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_dhcp_1_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the dhcp.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_dhcp_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the dhcp.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_dhcp_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dhcp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dhcp"
        init => "$zeek_dhcp_field_names = [ 'ts', 'uids', 'orig_h', 'resp_h', 'orig_l2_addr', 'host_name', 'client_fqdn', 'domain', 'requested_ip', 'assigned_ip', 'lease_time', 'client_message', 'server_message', 'msg_types', 'duration' ]"
        code => "event.set('[zeek_cols]', $zeek_dhcp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    # todo: handle mutiple DHCP uids

    if ((![zeek_cols][orig_p]) and (![zeek_cols][resp_p])) {
      mutate {
        id => "mutate_add_field_zeek_dhcp_ports"
        add_field => {
          "[zeek_cols][orig_p]" => 68
          "[zeek_cols][resp_p]" => 67
        }
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dhcp"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "dhcp"
      }
    }

  } else if ([source] == "dnp3") {
    #############################################################################################################################
    # dnp3.log

    dissect {
      id => "dissect_zeek_dnp3"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][fc_request]}	%{[zeek_cols][fc_reply]}	%{[zeek_cols][iin]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dnp3"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dnp3"
        init => "$zeek_dnp3_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'fc_request', 'fc_reply', 'iin' ]"
        code => "event.set('[zeek_cols]', $zeek_dnp3_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dnp3"
      add_field => {
        "[zeek_cols][service]" => "dnp3"
      }
    }

  } else if ([source] == "dns") {
    #############################################################################################################################
    # dns.log
    dissect {
      id => "dissect_zeek_dns"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][trans_id]}	%{[zeek_cols][rtt]}	%{[zeek_cols][query]}	%{[zeek_cols][qclass]}	%{[zeek_cols][qclass_name]}	%{[zeek_cols][qtype]}	%{[zeek_cols][qtype_name]}	%{[zeek_cols][rcode]}	%{[zeek_cols][rcode_name]}	%{[zeek_cols][AA]}	%{[zeek_cols][TC]}	%{[zeek_cols][RD]}	%{[zeek_cols][RA]}	%{[zeek_cols][Z]}	%{[zeek_cols][answers]}	%{[zeek_cols][TTLs]}	%{[zeek_cols][rejected]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dns"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dns"
        init => "$zeek_dns_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'trans_id', 'rtt', 'query', 'qclass', 'qclass_name', 'qtype', 'qtype_name', 'rcode', 'rcode_name', 'AA', 'TC', 'RD', 'RA', 'Z', 'answers', 'TTLs', 'rejected' ]"
        code => "event.set('[zeek_cols]', $zeek_dns_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_dns"
      add_field => {
        "[zeek_cols][service]" => "dns"
      }
    }

  } else if ([source] == "dpd") {
    #############################################################################################################################
    # dpd.log

    dissect {
      id => "dissect_zeek_dpd"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}	%{[zeek_cols][failure_reason]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_dpd"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_dpd"
        init => "$zeek_dpd_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'service', 'failure_reason' ]"
        code => "event.set('[zeek_cols]', $zeek_dpd_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_lowercase_zeek_dpd_service"
             lowercase => [ "[zeek_cols][service]" ] }

  } else if ([source] == "enip") {
    #############################################################################################################################
    # enip.log
    # https://github.com/amzn/zeek-plugin-enip

    dissect {
      id => "dissect_zeek_enip"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][command]}	%{[zeek_cols][length]}	%{[zeek_cols][session_handle]}	%{[zeek_cols][status]}	%{[zeek_cols][sender_context]}	%{[zeek_cols][options]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_enip"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_enip"
        init => "$zeek_enip_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'command', 'length', 'session_handle', 'status', 'sender_context', 'options' ]"
        code => "event.set('[zeek_cols]', $zeek_enip_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    # todo: translate enip options somehow?

    mutate {
      id => "mutate_add_fields_zeek_enip"
      add_field => {
        "[zeek_cols][service]" => "enip"
      }
    }

  } else if ([source] == "enip_list_identity") {
    #############################################################################################################################
    # enip_list_identity.log
    # https://github.com/amzn/zeek-plugin-enip

    dissect {
      id => "dissect_zeek_enip_list_identity"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][device_type]}	%{[zeek_cols][vendor]}	%{[zeek_cols][product_name]}	%{[zeek_cols][serial_number]}	%{[zeek_cols][product_code]}	%{[zeek_cols][revision]}	%{[zeek_cols][status]}	%{[zeek_cols][state]}	%{[zeek_cols][device_ip]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_enip_list_identity"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_enip_list_identity"
        init => "$zeek_enip_list_identity_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'device_type', 'vendor', 'product_name', 'serial_number', 'product_code', 'revision', 'status', 'state', 'device_ip' ]"
        code => "event.set('[zeek_cols]', $zeek_enip_list_identity_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_enip_list_identity"
      add_field => {
        "[zeek_cols][service]" => "enip"
      }
    }

  } else if ([source] == "files") {
    #############################################################################################################################
    # files.log

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap files.log field configuration version 0
      #
      # all fields (with extracted file size info) :    0x01FFFFFF / 33554431
      # all fields (without extracted file size info) : 0x007FFFFF / 8388607

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 33554431) {

          dissect {
            id => "dissect_zeek_files_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][tx_hosts]}	%{[zeek_cols][rx_hosts]}	%{[zeek_cols][conn_uids]}	%{[zeek_cols][source]}	%{[zeek_cols][depth]}	%{[zeek_cols][analyzers]}	%{[zeek_cols][mime_type]}	%{[zeek_cols][filename]}	%{[zeek_cols][duration]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][seen_bytes]}	%{[zeek_cols][total_bytes]}	%{[zeek_cols][missing_bytes]}	%{[zeek_cols][overflow_bytes]}	%{[zeek_cols][timedout]}	%{[zeek_cols][parent_fuid]}	%{[zeek_cols][md5]}	%{[zeek_cols][sha1]}	%{[zeek_cols][sha256]}	%{[zeek_cols][extracted]}	%{[zeek_cols][extracted_cutoff]}	%{[zeek_cols][extracted_size]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 8388607) {

          dissect {
            id => "dissect_zeek_files_with_all_fields_minus_extract_size"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][tx_hosts]}	%{[zeek_cols][rx_hosts]}	%{[zeek_cols][conn_uids]}	%{[zeek_cols][source]}	%{[zeek_cols][depth]}	%{[zeek_cols][analyzers]}	%{[zeek_cols][mime_type]}	%{[zeek_cols][filename]}	%{[zeek_cols][duration]}	%{[zeek_cols][local_orig]}	%{[zeek_cols][is_orig]}	%{[zeek_cols][seen_bytes]}	%{[zeek_cols][total_bytes]}	%{[zeek_cols][missing_bytes]}	%{[zeek_cols][overflow_bytes]}	%{[zeek_cols][timedout]}	%{[zeek_cols][parent_fuid]}	%{[zeek_cols][md5]}	%{[zeek_cols][sha1]}	%{[zeek_cols][sha256]}	%{[zeek_cols][extracted]}"
            }
          }

        } else {
          # who knows? the files.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_files_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the files.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_files_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the files.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_files_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_files"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_files"
        init => "$zeek_files_field_names = [ 'ts', 'fuid', 'tx_hosts', 'rx_hosts', 'conn_uids', 'source', 'depth', 'analyzers', 'mime_type', 'filename', 'duration', 'local_orig', 'is_orig', 'seen_bytes', 'total_bytes', 'missing_bytes', 'overflow_bytes', 'timedout', 'parent_fuid', 'md5', 'sha1', 'sha256', 'extracted', 'extracted_cutoff', 'extracted_size' ]"
        code => "event.set('[zeek_cols]', $zeek_files_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_files"
      add_field => {
        "[zeek_cols][uid]" => "%{[zeek_cols][fuid]}"
      }
    }

    if ([zeek_cols][conn_uids]) and ([zeek_cols][conn_uids] != '(empty)') and ([zeek_cols][conn_uids] != '') {
      mutate { id => "mutate_split_zeek_files_conn_uids"
               split => { "[zeek_cols][conn_uids]" => "," } }
    }
    if ([zeek_cols][tx_hosts]) and ([zeek_cols][tx_hosts] != '(empty)') and ([zeek_cols][tx_hosts] != '') {
      mutate { id => "mutate_split_zeek_files_tx_hosts"
               split => { "[zeek_cols][tx_hosts]" => "," } }
    }
    if ([zeek_cols][rx_hosts]) and ([zeek_cols][rx_hosts] != '(empty)') and ([zeek_cols][rx_hosts] != '') {
      mutate { id => "mutate_split_zeek_files_rx_hosts"
               split => { "[zeek_cols][rx_hosts]" => "," } }
    }

    if ([zeek_cols][conn_uids] and [zeek_cols][conn_uids][0]) {
      mutate { id => "mutate_add_field_zeek_files_conn_uids"
               add_field => { "[rootId]" => "%{[zeek_cols][conn_uids][0]}" } }
    }

    if ([zeek_cols][tx_hosts] and [zeek_cols][tx_hosts][0]) {
      mutate { id => "mutate_add_field_zeek_tx_hosts"
               add_field => { "[srcIp]" => "%{[zeek_cols][tx_hosts][0]}" } }
    }

    if ([zeek_cols][rx_hosts] and [zeek_cols][rx_hosts][0]) {
      mutate { id => "mutate_add_field_zeek_rx_hosts"
               add_field => { "[dstIp]" => "%{[zeek_cols][rx_hosts][0]}" } }
    }

  } else if ([source] == "ftp") {
    #############################################################################################################################
    # ftp.log

    dissect {
      id => "dissect_zeek_ftp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][command]}	%{[zeek_cols][arg]}	%{[zeek_cols][mime_type]}	%{[zeek_cols][file_size]}	%{[zeek_cols][reply_code]}	%{[zeek_cols][reply_msg]}	%{[zeek_cols][data_channel_passive]}	%{[zeek_cols][data_channel_orig_h]}	%{[zeek_cols][data_channel_resp_h]}	%{[zeek_cols][data_channel_resp_p]}	%{[zeek_cols][fuid]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ftp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ftp"
        init => "$zeek_ftp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'user', 'password', 'command', 'arg', 'mime_type', 'file_size', 'reply_code', 'reply_msg', 'data_channel_passive', 'data_channel_orig_h', 'data_channel_resp_h', 'data_channel_resp_p', 'fuid' ]"
        code => "event.set('[zeek_cols]', $zeek_ftp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ftp"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "ftp"
      }
    }

  } else if ([source] == "gquic") {
    #############################################################################################################################
    # gquic.log

    dissect {
      id => "dissect_zeek_gquic"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][server_name]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][tag_count]}	%{[zeek_cols][cyu]}	%{[zeek_cols][cyutags]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_gquic"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_gquic"
        init => "$zeek_gquic_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'server_name', 'user_agent', 'tag_count', 'cyu', 'cyutags' ]"
        code => "event.set('[zeek_cols]', $zeek_gquic_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_gquic"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "quic"
      }
    }

  } else if ([source] == "http") {
    #############################################################################################################################
    # http.log

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap http.log field configuration version 0
      # all fields:   0x3FFFFFFF / 1073741823
      # minus origin: 0x3FFFDFFF / 1073733631

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 1073741823) {
          dissect {
            id => "dissect_zeek_http_0_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][method]}	%{[zeek_cols][host]}	%{[zeek_cols][uri]}	%{[zeek_cols][referrer]}	%{[zeek_cols][version]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][origin]}	%{[zeek_cols][request_body_len]}	%{[zeek_cols][response_body_len]}	%{[zeek_cols][status_code]}	%{[zeek_cols][status_msg]}	%{[zeek_cols][info_code]}	%{[zeek_cols][info_msg]}	%{[zeek_cols][tags]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][proxied]}	%{[zeek_cols][orig_fuids]}	%{[zeek_cols][orig_filenames]}	%{[zeek_cols][orig_mime_types]}	%{[zeek_cols][resp_fuids]}	%{[zeek_cols][resp_filenames]}	%{[zeek_cols][resp_mime_types]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 1073733631) {
          dissect {
            id => "dissect_zeek_http_0_with_all_fields_minus_origin"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][method]}	%{[zeek_cols][host]}	%{[zeek_cols][uri]}	%{[zeek_cols][referrer]}	%{[zeek_cols][version]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][request_body_len]}	%{[zeek_cols][response_body_len]}	%{[zeek_cols][status_code]}	%{[zeek_cols][status_msg]}	%{[zeek_cols][info_code]}	%{[zeek_cols][info_msg]}	%{[zeek_cols][tags]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][proxied]}	%{[zeek_cols][orig_fuids]}	%{[zeek_cols][orig_filenames]}	%{[zeek_cols][orig_mime_types]}	%{[zeek_cols][resp_fuids]}	%{[zeek_cols][resp_filenames]}	%{[zeek_cols][resp_mime_types]}"
            }
          }

        } else {
          # who knows? the http.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_http_1_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the http.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_http_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the http.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_http_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_http"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_http"
        init => "$zeek_http_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'trans_depth', 'method', 'host', 'uri', 'referrer', 'version', 'user_agent', 'origin', 'request_body_len', 'response_body_len', 'status_code', 'status_msg', 'info_code', 'info_msg', 'tags', 'user', 'password', 'proxied', 'orig_fuids', 'orig_filenames', 'orig_mime_types', 'resp_fuids', 'resp_filenames', 'resp_mime_types' ]"
        code => "event.set('[zeek_cols]', $zeek_http_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_http"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "http"
      }
    }

  } else if ([source] == "intel") {
    #############################################################################################################################
    # intel.log

    dissect {
      id => "dissect_zeek_intel"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][indicator]}	%{[zeek_cols][indicator_type]}	%{[zeek_cols][seen_where]}	%{[zeek_cols][seen_node]}	%{[zeek_cols][matched]}	%{[zeek_cols][sources]}	%{[zeek_cols][fuid]}	%{[zeek_cols][file_mime_type]}	%{[zeek_cols][file_desc]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_intel"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_intel"
        init => "$zeek_intel_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'indicator', 'indicator_type', 'seen_where', 'seen_node', 'matched', 'sources', 'fuid', 'file_mime_type', 'file_desc' ]"
        code => "event.set('[zeek_cols]', $zeek_intel_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_intel"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "intel"
      }
    }

  } else if ([source] == "irc") {
    #############################################################################################################################
    # irc.log

    dissect {
      id => "dissect_zeek_irc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][nick]}	%{[zeek_cols][user]}	%{[zeek_cols][command]}	%{[zeek_cols][value]}	%{[zeek_cols][addl]}	%{[zeek_cols][dcc_file_name]}	%{[zeek_cols][dcc_file_size]}	%{[zeek_cols][dcc_mime_type]}	%{[zeek_cols][fuid]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_irc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_irc"
        init => "$zeek_irc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'nick', 'user', 'command', 'value', 'addl', 'dcc_file_name', 'dcc_file_size', 'dcc_mime_type', 'fuid' ]"
        code => "event.set('[zeek_cols]', $zeek_irc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_irc"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "irc"
      }
    }

  } else if ([source] == "iso_cotp") {
    #############################################################################################################################
    # iso_cotp.log
    # https://github.com/amzn/zeek-plugin-s7comm

    dissect {
      id => "dissect_zeek_iso_cotp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][pdu_type]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_iso_cotp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_iso_cotp"
        init => "$zeek_iso_cotp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'pdu_type' ]"
        code => "event.set('[zeek_cols]', $zeek_iso_cotp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_iso_cotp"
      add_field => {
        "[zeek_cols][service]" => "cotp"
      }
    }

  } else if ([source] == "kerberos") {
    #############################################################################################################################
    # kerberos.log

    dissect {
      id => "dissect_zeek_kerberos"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][request_type]}	%{[zeek_cols][cname]}	%{[zeek_cols][sname]}	%{[zeek_cols][success]}	%{[zeek_cols][error_msg]}	%{[zeek_cols][from]}	%{[zeek_cols][till]}	%{[zeek_cols][cipher]}	%{[zeek_cols][forwardable]}	%{[zeek_cols][renewable]}	%{[zeek_cols][client_cert_subject]}	%{[zeek_cols][client_cert_fuid]}	%{[zeek_cols][server_cert_subject]}	%{[zeek_cols][server_cert_fuid]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_kerberos"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_kerberos"
        init => "$zeek_kerberos_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'request_type', 'cname', 'sname', 'success', 'error_msg', 'from', 'till', 'cipher', 'forwardable', 'renewable', 'client_cert_subject', 'client_cert_fuid', 'server_cert_subject', 'server_cert_fuid' ]"
        code => "event.set('[zeek_cols]', $zeek_kerberos_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_krb5"
      add_field => {
        "[zeek_cols][service]" => "krb5"
      }
    }

  } else if ([source] == "known_certs") {
    #############################################################################################################################
    # known_certs.log

    dissect {
      id => "dissect_zeek_known_certs"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][subject]}	%{[zeek_cols][issuer_subject]}	%{[zeek_cols][serial]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_known_certs"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_known_certs"
        init => "$zeek_known_certs_field_names = [ 'ts', 'orig_h', 'orig_p', 'subject', 'resp_h', 'issuer_subject', 'serial' ]"
        code => "event.set('[zeek_cols]', $zeek_known_certs_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_known_certs"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tls"
      }
    }

  } else if ([source] == "known_hosts") {
    #############################################################################################################################
    # known_hosts.log

    dissect {
      id => "dissect_zeek_known_hosts"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_known_hosts"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_known_hosts"
        init => "$zeek_known_hosts_field_names = [ 'ts', 'orig_h' ]"
        code => "event.set('[zeek_cols]', $zeek_known_hosts_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([source] == "known_services") {
    #############################################################################################################################
    # known_services.log

    dissect {
      id => "dissect_zeek_known_services"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][service]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_known_services"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_known_services"
        init => "$zeek_known_services_field_names = [ 'ts', 'resp_h', 'resp_p', 'proto', 'service' ]"
        code => "event.set('[zeek_cols]', $zeek_known_services_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate { id => "mutate_lowercase_zeek_known_services_service"
             lowercase => [ "[zeek_cols][service]" ] }

  } else if ([source] == "modbus") {
    #############################################################################################################################
    # modbus.log

    dissect {
      id => "dissect_zeek_modbus"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][func]}	%{[zeek_cols][exception]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_modbus"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_modbus"
        init => "$zeek_modbus_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'func', 'exception' ]"
        code => "event.set('[zeek_cols]', $zeek_modbus_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_modbus"
      add_field => {
        "[zeek_cols][service]" => "modbus"
      }
    }

  } else if ([source] == "mqtt_connect") {
    #############################################################################################################################
    # mqtt_connect.log

    dissect {
      id => "dissect_zeek_mqtt_connect"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto_name]}	%{[zeek_cols][proto_version]}	%{[zeek_cols][client_id]}	%{[zeek_cols][connect_status]}	%{[zeek_cols][will_topic]}	%{[zeek_cols][will_payload]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_mqtt_connect"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_mqtt_connect"
        init => "$zeek_mqtt_connect_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto_name', 'proto_version', 'client_id', 'connect_status', 'will_topic', 'will_payload' ]"
        code => "event.set('[zeek_cols]', $zeek_mqtt_connect_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    # todo: other mqtt logs?

    mutate {
      id => "mutate_add_fields_zeek_mqtt_connect"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "mqtt"
      }
    }

  } else if ([source] == "mysql") {
    #############################################################################################################################
    # mysql.log

    dissect {
      id => "dissect_zeek_mysql"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][cmd]}	%{[zeek_cols][arg]}	%{[zeek_cols][success]}	%{[zeek_cols][rows]}	%{[zeek_cols][response]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_mysql"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_mysql"
        init => "$zeek_mysql_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'cmd', 'arg', 'success', 'rows', 'response' ]"
        code => "event.set('[zeek_cols]', $zeek_mysql_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_mysql"
      add_field => {
        "[zeek_cols][service]" => "mysql"
      }
    }

  } else if ([source] == "notice") {
    #############################################################################################################################
    # notice.log

    dissect {
      id => "dissect_zeek_notice"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][fuid]}	%{[zeek_cols][file_mime_type]}	%{[zeek_cols][file_desc]}	%{[zeek_cols][proto]}	%{[zeek_cols][note]}	%{[zeek_cols][msg]}	%{[zeek_cols][sub]}	%{[zeek_cols][src]}	%{[zeek_cols][dst]}	%{[zeek_cols][p]}	%{[zeek_cols][n]}	%{[zeek_cols][peer_descr]}	%{[zeek_cols][actions]}	%{[zeek_cols][suppress_for]}	%{[zeek_cols][dropped]}	%{[zeek_cols][remote_location_country_code]}	%{[zeek_cols][remote_location_region]}	%{[zeek_cols][remote_location_city]}	%{[zeek_cols][remote_location_latitude]}	%{[zeek_cols][remote_location_longitude]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_notice"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_notice"
        init => "$zeek_notice_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'fuid', 'file_mime_type', 'file_desc', 'proto', 'note', 'msg', 'sub', 'src', 'dst', 'p', 'n', 'peer_descr', 'actions', 'suppress_for', 'dropped', 'remote_location_country_code', 'remote_location_region', 'remote_location_city', 'remote_location_latitude', 'remote_location_longitude' ]"
        code => "event.set('[zeek_cols]', $zeek_notice_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    if (![zeek_cols][orig_h])       or ([zeek_cols][orig_h] == '(empty)') or
       ([zeek_cols][orig_h] == '-') or ([zeek_cols][orig_h] == '') {
      mutate { id => "mutate_replace_zeek_notice_orig_h"
               replace => { "[zeek_cols][orig_h]" => "%{[zeek_cols][src]}" } }
    }
    if (![zeek_cols][resp_h])       or ([zeek_cols][resp_h] == '(empty)') or
       ([zeek_cols][resp_h] == '-') or ([zeek_cols][resp_h] == '') {
      mutate { id => "mutate_replace_zeek_notice_resp_h"
               replace => { "[zeek_cols][resp_h]" => "%{[zeek_cols][dst]}" } }
    }
    if (![zeek_cols][resp_p])       or ([zeek_cols][resp_p] == '(empty)') or
       ([zeek_cols][resp_p] == '-') or ([zeek_cols][resp_p] == '') {
      mutate { id => "mutate_replace_zeek_resp_p"
               replace => { "[zeek_cols][resp_p]" => "%{[zeek_cols][p]}" } }
    }

  } else if ([source] == "ntlm") {
    #############################################################################################################################
    # ntlm.log

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap ntlm.log field configuration version 0
      #
      # all fields: 0x000007FF / 2047
      #
      # bitmap ntlm.log field configuration version 1
      #
      # all fields: 0x00001FFF / 8191

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 2047) {
          dissect {
            id => "dissect_zeek_ntlm_0_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user]}	%{[zeek_cols][host]}	%{[zeek_cols][domain]}	%{[zeek_cols][success]}	%{[zeek_cols][status]}"
            }
          }

        } else {
          # who knows? the ntlm.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_ntlm_0_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else if ([@metadata][zeek_fields_bitmap_version] == 1) {

        if ([@metadata][zeek_fields_bitmap] == 8191) {
          dissect {
            id => "dissect_zeek_ntlm_1_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user]}	%{[zeek_cols][host]}	%{[zeek_cols][domain]}	%{[zeek_cols][server_nb_computer]}	%{[zeek_cols][server_dns_computer]}	%{[zeek_cols][server_tree]}	%{[zeek_cols][success]}"
            }
          }

        } else {
          # who knows? the ntlm.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_ntlm_1_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the ntlm.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_ntlm_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the ntlm.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_ntlm_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ntlm"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ntlm"
        init => "$zeek_ntlm_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'user', 'host', 'domain', 'server_nb_computer', 'server_dns_computer', 'server_tree', 'success' ]"
        code => "event.set('[zeek_cols]', $zeek_ntlm_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ntlm"
      add_field => {
        "[zeek_cols][service]" => "ntlm"
      }
    }

  } else if ([source] == "ntp") {
    #############################################################################################################################
    # ntp.log
    # todo: https://docs.zeek.org/en/latest/scripts/base/protocols/ntp/main.zeek.html#type-NTP::Info
    # see if we can trasnlate some of these fields (mode, etc.) from codes into something more meaningful

    dissect {
      id => "dissect_zeek_ntp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][mode]}	%{[zeek_cols][stratum]}	%{[zeek_cols][poll]}	%{[zeek_cols][precision]}	%{[zeek_cols][root_delay]}	%{[zeek_cols][root_disp]}	%{[zeek_cols][ref_id]}	%{[zeek_cols][ref_time]}	%{[zeek_cols][org_time]}	%{[zeek_cols][rec_time]}	%{[zeek_cols][xmt_time]}	%{[zeek_cols][num_exts]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ntp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ntp"
        init => "$zeek_ntp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'mode', 'stratum', 'poll', 'precision', 'root_delay', 'root_disp', 'ref_id', 'ref_time', 'org_time', 'rec_time', 'xmt_time', 'num_exts' ]"
        code => "event.set('[zeek_cols]', $zeek_ntp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ntp"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "ntp"
      }
    }

  } else if ([source] == "pe") {
    #############################################################################################################################
    # pe.log

    dissect {
      id => "dissect_zeek_pe"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][machine]}	%{[zeek_cols][compile_ts]}	%{[zeek_cols][os]}	%{[zeek_cols][subsystem]}	%{[zeek_cols][is_exe]}	%{[zeek_cols][is_64bit]}	%{[zeek_cols][uses_aslr]}	%{[zeek_cols][uses_dep]}	%{[zeek_cols][uses_code_integrity]}	%{[zeek_cols][uses_seh]}	%{[zeek_cols][has_import_table]}	%{[zeek_cols][has_export_table]}	%{[zeek_cols][has_cert_table]}	%{[zeek_cols][has_debug_data]}	%{[zeek_cols][section_names]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_pe"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_pe"
        init => "$zeek_pe_field_names = [ 'ts', 'fuid', 'machine', 'compile_ts', 'os', 'subsystem', 'is_exe', 'is_64bit', 'uses_aslr', 'uses_dep', 'uses_code_integrity', 'uses_seh', 'has_import_table', 'has_export_table', 'has_cert_table', 'has_debug_data', 'section_names' ]"
        code => "event.set('[zeek_cols]', $zeek_pe_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([source] == "profinet") {
    #############################################################################################################################
    # profinet.log
    # https://github.com/amzn/zeek-plugin-profinet

    dissect {
      id => "dissect_zeek_profinet"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][operation_type]}	%{[zeek_cols][block_version]}	%{[zeek_cols][slot_number]}	%{[zeek_cols][subslot_number]}	%{[zeek_cols][index]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_profinet"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_profinet"
        init => "$zeek_profinet_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'operation_type', 'block_version', 'slot_number', 'subslot_number', 'index' ]"
        code => "event.set('[zeek_cols]', $zeek_profinet_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_profinet"
      add_field => {
        "[zeek_cols][service]" => "profinet"
      }
    }

  } else if ([source] == "profinet_dce_rpc") {
    #############################################################################################################################
    # profinet_dce_rpc.log
    # https://github.com/amzn/zeek-plugin-profinet

    dissect {
      id => "dissect_zeek_profinet_dce_rpc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][packet_type]}	%{[zeek_cols][object_uuid]}	%{[zeek_cols][interface_uuid]}	%{[zeek_cols][activity_uuid]}	%{[zeek_cols][server_boot_time]}	%{[zeek_cols][operation]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_profinet_dce_rpc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_profinet_dce_rpc"
        init => "$zeek_profinet_dce_rpc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'packet_type', 'object_uuid', 'interface_uuid', 'activity_uuid', 'server_boot_time', 'operation' ]"
        code => "event.set('[zeek_cols]', $zeek_profinet_dce_rpc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_profinet_dce_rpc"
      add_field => {
        "[zeek_cols][service]" => "profinet_dce_rpc"
      }
    }

  } else if ([source] == "radius") {
    #############################################################################################################################
    # radius.log

    dissect {
      id => "dissect_zeek_radius"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][user]}	%{[zeek_cols][mac]}	%{[zeek_cols][framed_addr]}	%{[zeek_cols][remote_ip]}	%{[zeek_cols][connect_info]}	%{[zeek_cols][reply_msg]}	%{[zeek_cols][result]}	%{[zeek_cols][ttl]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_radius"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_radius"
        init => "$zeek_radius_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'user', 'mac', 'framed_addr', 'remote_ip', 'connect_info', 'reply_msg', 'result', 'ttl' ]"
        code => "event.set('[zeek_cols]', $zeek_radius_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_radius"
      add_field => {
        "[zeek_cols][service]" => "radius"
      }
    }

  } else if ([source] == "rdp") {
    #############################################################################################################################
    # rdp.log

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap rdp.log field configuration version 0
      # all fields:             0x03FFFFF / 4194303
      # minus client_channels:  0x03FFDFF / 4193791

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 4194303) {
          dissect {
            id => "dissect_zeek_rdp_0_with_all_fields"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][cookie]}	%{[zeek_cols][result]}	%{[zeek_cols][security_protocol]}	%{[zeek_cols][client_channels]}	%{[zeek_cols][keyboard_layout]}	%{[zeek_cols][client_build]}	%{[zeek_cols][client_name]}	%{[zeek_cols][client_dig_product_id]}	%{[zeek_cols][desktop_width]}	%{[zeek_cols][desktop_height]}	%{[zeek_cols][requested_color_depth]}	%{[zeek_cols][cert_type]}	%{[zeek_cols][cert_count]}	%{[zeek_cols][cert_permanent]}	%{[zeek_cols][encryption_level]}	%{[zeek_cols][encryption_method]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 4193791) {
          dissect {
            id => "dissect_zeek_rdp_0_with_all_fields_minus_client_channels"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][cookie]}	%{[zeek_cols][result]}	%{[zeek_cols][security_protocol]}	%{[zeek_cols][keyboard_layout]}	%{[zeek_cols][client_build]}	%{[zeek_cols][client_name]}	%{[zeek_cols][client_dig_product_id]}	%{[zeek_cols][desktop_width]}	%{[zeek_cols][desktop_height]}	%{[zeek_cols][requested_color_depth]}	%{[zeek_cols][cert_type]}	%{[zeek_cols][cert_count]}	%{[zeek_cols][cert_permanent]}	%{[zeek_cols][encryption_level]}	%{[zeek_cols][encryption_method]}"
            }
          }

        } else {
          # who knows? the rdp.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_rdp_1_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the rdp.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_rdp_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the rdp.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_rdp_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_rdp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_rdp"
        init => "$zeek_rdp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'cookie', 'result', 'security_protocol', 'client_channels', 'keyboard_layout', 'client_build', 'client_name', 'client_dig_product_id', 'desktop_width', 'desktop_height', 'requested_color_depth', 'cert_type', 'cert_count', 'cert_permanent', 'encryption_level', 'encryption_method' ]"
        code => "event.set('[zeek_cols]', $zeek_rdp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_rdp"
      add_field => {
        "[zeek_cols][service]" => "rdp"
      }
    }

  } else if ([source] == "rfb") {
    #############################################################################################################################
    # rfb.log

    dissect {
      id => "dissect_zeek_rfb"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][client_major_version]}	%{[zeek_cols][client_minor_version]}	%{[zeek_cols][server_major_version]}	%{[zeek_cols][server_minor_version]}	%{[zeek_cols][authentication_method]}	%{[zeek_cols][auth]}	%{[zeek_cols][share_flag]}	%{[zeek_cols][desktop_name]}	%{[zeek_cols][width]}	%{[zeek_cols][height]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_rfb"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_rfb"
        init => "$zeek_rfb_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'client_major_version', 'client_minor_version', 'server_major_version', 'server_minor_version', 'authentication_method', 'auth', 'share_flag', 'desktop_name', 'width', 'height' ]"
        code => "event.set('[zeek_cols]', $zeek_rfb_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_rfb"
      add_field => {
        "[zeek_cols][service]" => "rfb"
      }
    }

  } else if ([source] == "s7comm") {
    #############################################################################################################################
    # s7comm.log
    # https://github.com/amzn/zeek-plugin-s7comm

    dissect {
      id => "dissect_zeek_s7comm"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][rosctr]}	%{[zeek_cols][parameter]}	%{[zeek_cols][item_count]}	%{[zeek_cols][data_info]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_s7comm"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_s7comm"
        init => "$zeek_s7comm_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'rosctr', 'parameter', 'item_count', 'data_info' ]"
        code => "event.set('[zeek_cols]', $zeek_s7comm_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_s7comm"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "s7comm"
      }
    }

    # todo: split up/assign parameter value and data_info value

  } else if ([source] == "signatures") {
    #############################################################################################################################
    # signatures.log

    dissect {
      id => "dissect_zeek_signatures"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][note]}	%{[zeek_cols][signature_id]}	%{[zeek_cols][event_message]}	%{[zeek_cols][sub_message]}	%{[zeek_cols][signature_count]}	%{[zeek_cols][host_count]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_signatures"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_signatures"
        init => "$zeek_signatures_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'note', 'signature_id', 'event_message', 'sub_message', 'signature_count', 'host_count' ]"
        code => "event.set('[zeek_cols]', $zeek_signatures_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([source] == "sip") {
    #############################################################################################################################
    # sip.log

    dissect {
      id => "dissect_zeek_sip"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][method]}	%{[zeek_cols][uri]}	%{[zeek_cols][date]}	%{[zeek_cols][request_from]}	%{[zeek_cols][request_to]}	%{[zeek_cols][response_from]}	%{[zeek_cols][response_to]}	%{[zeek_cols][reply_to]}	%{[zeek_cols][call_id]}	%{[zeek_cols][seq]}	%{[zeek_cols][subject]}	%{[zeek_cols][request_path]}	%{[zeek_cols][response_path]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][status_code]}	%{[zeek_cols][status_msg]}	%{[zeek_cols][warning]}	%{[zeek_cols][request_body_len]}	%{[zeek_cols][response_body_len]}	%{[zeek_cols][content_type]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_sip"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_sip"
        init => "$zeek_sip_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'trans_depth', 'method', 'uri', 'date', 'request_from', 'request_to', 'response_from', 'response_to', 'reply_to', 'call_id', 'seq', 'subject', 'request_path', 'response_path', 'user_agent', 'status_code', 'status_msg', 'warning', 'request_body_len', 'response_body_len', 'content_type' ]"
        code => "event.set('[zeek_cols]', $zeek_sip_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_sip"
      add_field => {
        "[zeek_cols][service]" => "sip"
      }
    }

  } else if ([source] == "smb_files") {
    #############################################################################################################################
    # smb_files.log

    dissect {
      id => "dissect_zeek_smb_files"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][fuid]}	%{[zeek_cols][action]}	%{[zeek_cols][path]}	%{[zeek_cols][name]}	%{[zeek_cols][size]}	%{[zeek_cols][prev_name]}	%{[zeek_cols][times_modified]}	%{[zeek_cols][times_accessed]}	%{[zeek_cols][times_created]}	%{[zeek_cols][times_changed]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_smb_files"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_smb_files"
        init => "$zeek_smb_files_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'fuid', 'action', 'path', 'name', 'size', 'prev_name', 'times_modified', 'times_accessed', 'times_created', 'times_changed' ]"
        code => "event.set('[zeek_cols]', $zeek_smb_files_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_smb_files"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "smb"
      }
    }

  } else if ([source] == "smb_mapping") {
    #############################################################################################################################
    # smb_mapping.log

    dissect {
      id => "dissect_zeek_smb_mapping"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][path]}	%{[zeek_cols][resource_type]}	%{[zeek_cols][native_file_system]}	%{[zeek_cols][share_type]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_smb_mapping"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_smb_mapping"
        init => "$zeek_smb_mapping_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'path', 'resource_type', 'native_file_system', 'share_type' ]"
        code => "event.set('[zeek_cols]', $zeek_smb_mapping_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_smb_mapping"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "smb"
      }
    }

  } else if ([source] == "smtp") {
    #############################################################################################################################
    # smtp.log

    dissect {
      id => "dissect_zeek_smtp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][trans_depth]}	%{[zeek_cols][helo]}	%{[zeek_cols][mailfrom]}	%{[zeek_cols][rcptto]}	%{[zeek_cols][date]}	%{[zeek_cols][from]}	%{[zeek_cols][to]}	%{[zeek_cols][cc]}	%{[zeek_cols][reply_to]}	%{[zeek_cols][msg_id]}	%{[zeek_cols][in_reply_to]}	%{[zeek_cols][subject]}	%{[zeek_cols][x_originating_ip]}	%{[zeek_cols][first_received]}	%{[zeek_cols][second_received]}	%{[zeek_cols][last_reply]}	%{[zeek_cols][path]}	%{[zeek_cols][user_agent]}	%{[zeek_cols][tls]}	%{[zeek_cols][fuids]}	%{[zeek_cols][is_webmail]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_smtp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_smtp"
        init => "$zeek_smtp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'trans_depth', 'helo', 'mailfrom', 'rcptto', 'date', 'from', 'to', 'cc', 'reply_to', 'msg_id', 'in_reply_to', 'subject', 'x_originating_ip', 'first_received', 'second_received', 'last_reply', 'path', 'user_agent', 'tls', 'fuids', 'is_webmail' ]"
        code => "event.set('[zeek_cols]', $zeek_smtp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_smtp"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "smtp"
      }
    }

  } else if ([source] == "snmp") {
    #############################################################################################################################
    # snmp.log

    dissect {
      id => "dissect_zeek_snmp"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][duration]}	%{[zeek_cols][version]}	%{[zeek_cols][community]}	%{[zeek_cols][get_requests]}	%{[zeek_cols][get_bulk_requests]}	%{[zeek_cols][get_responses]}	%{[zeek_cols][set_requests]}	%{[zeek_cols][display_string]}	%{[zeek_cols][up_since]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_snmp"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_snmp"
        init => "$zeek_snmp_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'duration', 'version', 'community', 'get_requests', 'get_bulk_requests', 'get_responses', 'set_requests', 'display_string', 'up_since' ]"
        code => "event.set('[zeek_cols]', $zeek_snmp_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_snmp"
      add_field => {
        "[zeek_cols][proto]" => "udp"
        "[zeek_cols][service]" => "snmp"
      }
    }

  } else if ([source] == "socks") {
    #############################################################################################################################
    # socks.log

    dissect {
      id => "dissect_zeek_socks"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][user]}	%{[zeek_cols][password]}	%{[zeek_cols][server_status]}	%{[zeek_cols][request_host]}	%{[zeek_cols][request_name]}	%{[zeek_cols][request_port]}	%{[zeek_cols][bound_host]}	%{[zeek_cols][bound_name]}	%{[zeek_cols][bound_port]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_socks"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_socks"
        init => "$zeek_socks_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'user', 'password', 'server_status', 'request_host', 'request_name', 'request_port', 'bound_host', 'bound_name', 'bound_port' ]"
        code => "event.set('[zeek_cols]', $zeek_socks_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_socks"
      add_field => {
        "[zeek_cols][service]" => "socks"
      }
    }

  } else if ([source] == "software") {
    #############################################################################################################################
    # software.log

    dissect {
      id => "dissect_zeek_software"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][software_type]}	%{[zeek_cols][name]}	%{[zeek_cols][version_major]}	%{[zeek_cols][version_minor]}	%{[zeek_cols][version_minor2]}	%{[zeek_cols][version_minor3]}	%{[zeek_cols][version_addl]}	%{[zeek_cols][unparsed_version]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_software"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_software"
        init => "$zeek_software_field_names = [ 'ts', 'orig_h', 'orig_p', 'software_type', 'name', 'version_major', 'version_minor', 'version_minor2', 'version_minor3', 'version_addl', 'unparsed_version' ]"
        code => "event.set('[zeek_cols]', $zeek_software_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([source] == "ssh") {
    #############################################################################################################################
    # ssh.log

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap ssh.log field configuration version 0
      #
      # standard ssh.log without HASSH fingerprinting add-on script : 0x007FFFFF / 8388607
      # ssh.log with HASSH fingerprinting add-on script :             0x3FFFFFFF / 1073741823

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 1073741823) {

          dissect {
            id => "dissect_zeek_ssh_with_all_fields_with_hassh"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][auth_success]}	%{[zeek_cols][auth_attempts]}	%{[zeek_cols][direction]}	%{[zeek_cols][client]}	%{[zeek_cols][server]}	%{[zeek_cols][cipher_alg]}	%{[zeek_cols][mac_alg]}	%{[zeek_cols][compression_alg]}	%{[zeek_cols][kex_alg]}	%{[zeek_cols][host_key_alg]}	%{[zeek_cols][host_key]}	%{[zeek_cols][remote_location_country_code]}	%{[zeek_cols][remote_location_region]}	%{[zeek_cols][remote_location_city]}	%{[zeek_cols][remote_location_latitude]}	%{[zeek_cols][remote_location_longitude]}	%{[zeek_cols][hasshVersion]}	%{[zeek_cols][hassh]}	%{[zeek_cols][hasshServer]}	%{[zeek_cols][cshka]}	%{[zeek_cols][hasshAlgorithms]}	%{[zeek_cols][sshka]}	%{[zeek_cols][hasshServerAlgorithms]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 8388607) {

          dissect {
            id => "dissect_zeek_ssh_with_all_fields_no_hassh"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][version]}	%{[zeek_cols][auth_success]}	%{[zeek_cols][auth_attempts]}	%{[zeek_cols][direction]}	%{[zeek_cols][client]}	%{[zeek_cols][server]}	%{[zeek_cols][cipher_alg]}	%{[zeek_cols][mac_alg]}	%{[zeek_cols][compression_alg]}	%{[zeek_cols][kex_alg]}	%{[zeek_cols][host_key_alg]}	%{[zeek_cols][host_key]}	%{[zeek_cols][remote_location_country_code]}	%{[zeek_cols][remote_location_region]}	%{[zeek_cols][remote_location_city]}	%{[zeek_cols][remote_location_latitude]}	%{[zeek_cols][remote_location_longitude]}"
            }
          }

        } else {
          # who knows? the ssh.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_ssh_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the ssh.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_ssh_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the ssh.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_ssh_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ssh"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ssh"
        init => "$zeek_ssh_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'version', 'auth_success', 'auth_attempts', 'direction', 'client', 'server', 'cipher_alg', 'mac_alg', 'compression_alg', 'kex_alg', 'host_key_alg', 'host_key', 'remote_location_country_code', 'remote_location_region', 'remote_location_city', 'remote_location_latitude', 'remote_location_longitude', 'hasshVersion', 'hassh', 'hasshServer', 'cshka', 'hasshAlgorithms', 'sshka', 'hasshServerAlgorithms' ]"
        code => "event.set('[zeek_cols]', $zeek_ssh_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ssh"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "ssh"
      }
    }

  } else if ([source] == "ssl") {
    #############################################################################################################################
    # ssl.log

    if ([@metadata][zeek_fields_bitmap] and [@metadata][zeek_fields_bitmap_version]) {

      # bitmap ssl.log field configuration version 0
      #
      # standard ssl.log fields without add-on JA3 fingerprinting script :  0x001FFFFF / 2097151
      # ssl.log fields with add-on JA3 fingerprinting script :              0x007FFFFF / 8388607

      if ([@metadata][zeek_fields_bitmap_version] == 0) {

        if ([@metadata][zeek_fields_bitmap] == 8388607) {

          dissect {
            id => "dissect_zeek_ssl_with_ja3"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][ssl_version]}	%{[zeek_cols][cipher]}	%{[zeek_cols][curve]}	%{[zeek_cols][server_name]}	%{[zeek_cols][resumed]}	%{[zeek_cols][last_alert]}	%{[zeek_cols][next_protocol]}	%{[zeek_cols][established]}	%{[zeek_cols][cert_chain_fuids]}	%{[zeek_cols][client_cert_chain_fuids]}	%{[zeek_cols][subject]}	%{[zeek_cols][issuer]}	%{[zeek_cols][client_subject]}	%{[zeek_cols][client_issuer]}	%{[zeek_cols][validation_status]}	%{[zeek_cols][ja3]}	%{[zeek_cols][ja3s]}"
            }
          }

        } else if ([@metadata][zeek_fields_bitmap] == 2097151) {

          dissect {
            id => "dissect_zeek_ssl_without_ja3"
            # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
            mapping => {
              "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][ssl_version]}	%{[zeek_cols][cipher]}	%{[zeek_cols][curve]}	%{[zeek_cols][server_name]}	%{[zeek_cols][resumed]}	%{[zeek_cols][last_alert]}	%{[zeek_cols][next_protocol]}	%{[zeek_cols][established]}	%{[zeek_cols][cert_chain_fuids]}	%{[zeek_cols][client_cert_chain_fuids]}	%{[zeek_cols][subject]}	%{[zeek_cols][issuer]}	%{[zeek_cols][client_subject]}	%{[zeek_cols][client_issuer]}	%{[zeek_cols][validation_status]}"
            }
          }

        } else {
          # who knows? the ssl.log preprocessed bitmap is not one we're expecting, we've got to guess and cannot use dissect
          mutate { id => "mutate_add_tag_dissect_failure_unknown_ssl_bitmap"
                   add_tag => [ "_dissectfailure" ] }
        }

      } else {
        # who knows? the ssl.log preprocessed bitmap field list version is not one we're expecting, we've got to guess and cannot use dissect
        mutate { id => "mutate_add_tag_dissect_failure_unknown_bitmap_ssl_version"
                 add_tag => [ "_dissectfailure" ] }
      }

    } else {
      # who knows? the ssl.log was not preprocessed to determine fields, we've got to guess and cannot use dissect
      mutate { id => "mutate_add_tag_dissect_failure_missing_ssl_bitmap"
               add_tag => [ "_dissectfailure" ] }
    }

    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_ssl"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_ssl"
        init => "$zeek_ssl_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'ssl_version', 'cipher', 'curve', 'server_name', 'resumed', 'last_alert', 'next_protocol', 'established', 'cert_chain_fuids', 'client_cert_chain_fuids', 'subject', 'issuer', 'client_subject', 'client_issuer', 'validation_status', 'ja3', 'ja3s' ]"
        code => "event.set('[zeek_cols]', $zeek_ssl_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_ssl"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tls"
      }
    }

  } else if ([source] == "syslog") {
    #############################################################################################################################
    # syslog.log

    dissect {
      id => "dissect_zeek_syslog"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][proto]}	%{[zeek_cols][facility]}	%{[zeek_cols][severity]}	%{[zeek_cols][message]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_syslog"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_syslog"
        init => "$zeek_syslog_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'proto', 'facility', 'severity', 'message' ]"
        code => "event.set('[zeek_cols]', $zeek_syslog_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_syslog"
      add_field => {
        "[zeek_cols][service]" => "syslog"
      }
    }

  } else if ([source] == "tds") {
    #############################################################################################################################
    # tds.log
    # https://github.com/amzn/zeek-plugin-tds

    dissect {
      id => "dissect_zeek_tds"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][command]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tds"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tds"
        init => "$zeek_tds_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'command' ]"
        code => "event.set('[zeek_cols]', $zeek_tds_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_tds"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tds"
      }
    }

  } else if ([source] == "tds_rpc") {
    #############################################################################################################################
    # tds_rpc.log
    # https://github.com/amzn/zeek-plugin-tds

    dissect {
      id => "dissect_zeek_tds_rpc"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][procedure_name]}	%{[zeek_cols][parameters]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tds_rpc"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tds_rpc"
        init => "$zeek_tds_rpc_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'procedure_name', 'parameters' ]"
        code => "event.set('[zeek_cols]', $zeek_tds_rpc_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_tds_rpc"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tds"
      }
    }

    # todo: split up/assign parameters field

  } else if ([source] == "tds_sql_batch") {
    #############################################################################################################################
    # tds_sql_batch.log
    # https://github.com/amzn/zeek-plugin-tds

    dissect {
      id => "dissect_zeek_tds_sql_batch"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][header_type]}	%{[zeek_cols][query]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tds_sql_batch"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tds_sql_batch"
        init => "$zeek_tds_sql_batch_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'header_type', 'query' ]"
        code => "event.set('[zeek_cols]', $zeek_tds_sql_batch_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_tds_sql_batch"
      add_field => {
        "[zeek_cols][proto]" => "tcp"
        "[zeek_cols][service]" => "tds"
      }
    }

  } else if ([source] == "tunnel") {
    #############################################################################################################################
    # tunnel.log

    dissect {
      id => "dissect_zeek_tunnel"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][tunnel_type]}	%{[zeek_cols][action]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_tunnel"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_tunnel"
        init => "$zeek_tunnel_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'tunnel_type', 'action' ]"
        code => "event.set('[zeek_cols]', $zeek_tunnel_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_tunnel"
      add_field => {
        "[zeek_cols][service]" => "%{[zeek_cols][tunnel_type]}"
      }
    }

    mutate { id => "mutate_lowercase_zeek_tunnel_service"
             lowercase => [ "[zeek_cols][service]" ] }
    mutate { id => "mutate_gsub_zeek_tunnel_service"
             gsub => [ "[zeek_cols][service]", "tunnel::", "" ] }

  } else if ([source] == "weird") {
    #############################################################################################################################
    # weird.log

    dissect {
      id => "dissect_zeek_weird"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][uid]}	%{[zeek_cols][orig_h]}	%{[zeek_cols][orig_p]}	%{[zeek_cols][resp_h]}	%{[zeek_cols][resp_p]}	%{[zeek_cols][name]}	%{[zeek_cols][addl]}	%{[zeek_cols][notice]}	%{[zeek_cols][peer]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_weird"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_weird"
        init => "$zeek_weird_field_names = [ 'ts', 'uid', 'orig_h', 'orig_p', 'resp_h', 'resp_p', 'name', 'addl', 'notice', 'peer' ]"
        code => "event.set('[zeek_cols]', $zeek_weird_field_names.zip(event.get('[message]')).to_h)"
      }
    }

  } else if ([source] == "x509") {
    #############################################################################################################################
    # x509.log

    dissect {
      id => "dissect_zeek_x509"
      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      mapping => {
        "[message]" => "%{[zeek_cols][ts]}	%{[zeek_cols][fuid]}	%{[zeek_cols][certificate_version]}	%{[zeek_cols][certificate_serial]}	%{[zeek_cols][certificate_subject]}	%{[zeek_cols][certificate_issuer]}	%{[zeek_cols][certificate_not_valid_before]}	%{[zeek_cols][certificate_not_valid_after]}	%{[zeek_cols][certificate_key_alg]}	%{[zeek_cols][certificate_sig_alg]}	%{[zeek_cols][certificate_key_type]}	%{[zeek_cols][certificate_key_length]}	%{[zeek_cols][certificate_exponent]}	%{[zeek_cols][certificate_curve]}	%{[zeek_cols][san_dns]}	%{[zeek_cols][san_uri]}	%{[zeek_cols][san_email]}	%{[zeek_cols][san_ip]}	%{[zeek_cols][basic_constraints_ca]}	%{[zeek_cols][basic_constraints_path_len]}"
      }
    }
    if ("_dissectfailure" in [tags]) {
      mutate {
        id => "mutate_split_zeek_x509"
        # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
        split => { "[message]" => "	" }
      }
      ruby {
        id => "ruby_zip_zeek_x509"
        init => "$zeek_x509_field_names = [ 'ts', 'fuid', 'certificate_version', 'certificate_serial', 'certificate_subject', 'certificate_issuer', 'certificate_not_valid_before', 'certificate_not_valid_after', 'certificate_key_alg', 'certificate_sig_alg', 'certificate_key_type', 'certificate_key_length', 'certificate_exponent', 'certificate_curve', 'san_dns', 'san_uri', 'san_email', 'san_ip', 'basic_constraints_ca', 'basic_constraints_path_len' ]"
        code => "event.set('[zeek_cols]', $zeek_x509_field_names.zip(event.get('[message]')).to_h)"
      }
    }

    mutate {
      id => "mutate_add_fields_zeek_x509"
      add_field => {
        "[zeek_cols][service]" => "X.509"
        "[certCnt]" => "1"
      }
    }

    dissect {
      id => "dissect_zeek_x509_convert_datatype_certCnt"
      convert_datatype => {
        "[certCnt]" => "int"
      }
    }

  } else {
    # some other unknown zeek log file. should start with ts at least!
    csv {
      id => "csv_zeek_unknown"
      columns => [
        "ts"]

      # zeek's default delimiter is a literal tab, MAKE SURE YOUR EDITOR DOESN'T SCREW IT UP
      separator => "	"
      # there's no way to *disable* the csv quote char, so set it to something we'll never see
      quote_char => ""

      target => "[zeek_cols]"
    }

    mutate { id => "mutate_add_tag_zeek_unknown"
             add_tag => [ "_unknown_log_type" ] }

  } # if / else if for source type (conn.log, dns.log, etc.)

  if ([zeek_cols]) {
    # remove unset (-) or "(empty)" field values
    ruby {
      id => "ruby_zeek_remove_empty_values"
      code => "
        fieldsHash = event.get('[zeek_cols]').to_hash
        fieldsHash.delete_if{|_,v| ((v == nil) or (v == '') or (v == '-') or (v == '(empty)'))}
        event.set('[zeek_cols]', fieldsHash)
      "
    }
  } else {
    drop { id => "drop_dissect_error" }
  }

  # rename the zeek child array to match the log type
  mutate { id => "mutate_rename_zeek_log_type"
           rename => { "[zeek_cols]" => "[zeek_%{[source]}]" } }

  # move "up" some fields that are considered to be "multi-log" fields (eg., they
  # show up in many types of logs)
  mutate {
    id => "mutate_rename_zeek_common_fields"
    rename => { "[zeek_%{[source]}][ts]"            => "[zeek][ts]" }
    rename => { "[zeek_%{[source]}][uid]"           => "[zeek][uid]" }
    rename => { "[zeek_%{[source]}][orig_h]"        => "[zeek][orig_h]" }
    rename => { "[zeek_%{[source]}][orig_p]"        => "[zeek][orig_p]" }
    rename => { "[zeek_%{[source]}][orig_l2_addr]"  => "[zeek][orig_l2_addr]" }
    rename => { "[zeek_%{[source]}][resp_h]"        => "[zeek][resp_h]" }
    rename => { "[zeek_%{[source]}][resp_p]"        => "[zeek][resp_p]" }
    rename => { "[zeek_%{[source]}][resp_l2_addr]"  => "[zeek][resp_l2_addr]" }
    rename => { "[zeek_%{[source]}][proto]"         => "[zeek][proto]" }
    rename => { "[zeek_%{[source]}][service]"       => "[zeek][service]" }
    rename => { "[zeek_%{[source]}][user]"          => "[zeek][user]" }
    rename => { "[zeek_%{[source]}][community_id]"  => "[zeek][community_id]" }
  }

  if ([zeek][orig_h]) { mutate { id => "mutate_add_field_zeek_srcIp"
                                 add_field => { "[srcIp]"   => "%{[zeek][orig_h]}" } } }
  if ([zeek][orig_p]) { mutate { id => "mutate_add_field_zeek_srcPort"
                                 add_field => { "[srcPort]" => "%{[zeek][orig_p]}" } } }
  if ([zeek][resp_h]) { mutate { id => "mutate_add_field_zeek_dstIp"
                                 add_field => { "[dstIp]"   => "%{[zeek][resp_h]}" } } }
  if ([zeek][resp_p]) { mutate { id => "mutate_add_field_zeek_dstPort"
                                 add_field => { "[dstPort]" => "%{[zeek][resp_p]}" } } }
  if ([zeek][community_id]) { mutate { id => "mutate_add_field_zeek_communityId"
                                       add_field => { "[communityId]" => "%{[zeek][community_id]}" } } }

  # if OUI lookup is requested, enable it
  mutate {
    add_field => { "[@metadata][ENV_LOGSTASH_OUI_LOOKUP]" => "${LOGSTASH_OUI_LOOKUP:false}" }
  }

  if ([zeek][orig_l2_addr]) {
    # copy orig_l2_addr into srcMac array (with a count of 1)
    mutate { id => "mutate_merge_field_zeek_srcMac"
             merge => { "[srcMac]" => "[zeek][orig_l2_addr]" } }
    mutate { id => "mutate_add_field_zeek_srcMacCnt"
             add_field => { "[srcMacCnt]" => "1" } }
    dissect {
      id => "dissect_convert_datatype_zeek_srcMacCnt"
      convert_datatype => {
        "[srcMacCnt]" => "int"
      }
    }
    if ([@metadata][ENV_LOGSTASH_OUI_LOOKUP] == "true") {
      # attempt lookup of srcMac oui
      ieee_oui {
        id => "ieee_oui_srcMac"
        source => "[zeek][orig_l2_addr]"
        target => "[zeek][orig_l2_oui]"
        ouifile => "/usr/share/logstash/config/oui-logstash.txt"
        refresh_interval => 0
      }
      if ([zeek][orig_l2_oui]) {
        # merge orig_l2_oui into srcOui array (with a count of 1)
        mutate { id => "mutate_merge_field_zeek_srcOui"
                 merge => { "[srcOui]" => "[zeek][orig_l2_oui]" } }
        mutate { id => "mutate_add_field_zeek_srcOuiCnt"
                 add_field => { "[srcOuiCnt]" => "1" } }
        dissect {
          id => "dissect_convert_datatype_zeek_srcOuiCnt"
          convert_datatype => {
            "[srcOuiCnt]" => "int"
          }
        }
      }
    }
  }

  if ([zeek][resp_l2_addr]) {
    # copy resp_l2_addr into dstMac array (with a count of 1)
    mutate { id => "mutate_merge_field_zeek_dstMac"
             merge => { "[dstMac]" => "[zeek][resp_l2_addr]" } }
    mutate { id => "mutate_add_field_zeek_dstMacCnt"
             add_field => { "[dstMacCnt]" => "1" } }
    dissect {
      id => "dissect_convert_datatype_zeek_dstMacCnt"
      convert_datatype => {
        "[dstMacCnt]" => "int"
      }
    }
    if ([@metadata][ENV_LOGSTASH_OUI_LOOKUP] == "true") {
      # attempt lookup of dstMac oui
      ieee_oui {
        id => "ieee_oui_dstMac"
        source => "[zeek][resp_l2_addr]"
        target => "[zeek][resp_l2_oui]"
        ouifile => "/usr/share/logstash/config/oui-logstash.txt"
        refresh_interval => 0
      }
      if ([zeek][resp_l2_oui]) {
        # merge resp_l2_oui into dstOui array (with a count of 1)
        mutate { id => "mutate_merge_field_zeek_dstOui"
                 merge => { "[dstOui]" => "[zeek][resp_l2_oui]" } }
        mutate { id => "mutate_add_field_zeek_dstOuiCnt"
                 add_field => { "[dstOuiCnt]" => "1" } }
        dissect {
          id => "dissect_convert_datatype_zeek_dstOuiCnt"
          convert_datatype => {
            "[dstOuiCnt]" => "int"
          }
        }
      }
    }
  }

  if ([zeek][uid]) {
    # set zeek connection UID as "rootId" (see logstash.conf output section)
    if (![rootId]) { mutate { id => "mutate_add_field_zeek_rootId"
                              add_field => { "[rootId]" => "%{[zeek][uid]}" } } }

  } else {
    # create something random for zeek connection UID
    uuid {
      id => "uuid_zeek_random_conn"
      target    => "[@metadata][uuid]"
      overwrite => true
    }
    mutate { id => "mutate_add_field_zeek_uid"
             add_field => { "[zeek][uid]" => "%{[@metadata][uuid]}" } }
  }

  if ([source] == "conn") {
    mutate { id => "mutate_add_field_zeek_conn_zeekLogDocId"
             add_field => { "[zeekLogDocId]" => "%{[zeek][uid]}" } }

  } else {
    if ([offset]) {
      mutate { id => "mutate_add_field_zeek_not_conn_offset_zeekLogDocId"
               add_field => { "[zeekLogDocId]" => "%{[zeek][uid]}-%{source}-%{offset}" } }
    } else {
      uuid {
        id => "uuid_zeek_random_not_conn"
        target    => "[@metadata][uuid]"
        overwrite => true
      }
      mutate { id => "mutate_add_field_zeek_not_conn_zeekLogDocId"
               add_field => { "[zeekLogDocId]" => "%{[zeek][uid]}-%{source}:%{[@metadata][uuid]}" } }
    }
  } # if/else for defining logOffset field used in document ID for elasticsearch

  if ([zeek][ts]) {

    if ([zeek][ts] == "0.000000") {
      # missing packet timestamp, set to "now." not sure what a better option would be
      ruby {
        id => "ruby_zeek_empty_timestamp_set"
        init => "require 'time'"
        code => "event.set('[zeek][ts]', Time.now.to_f)"
      }
      mutate { id => "tag_zeek_empty_timestamp_set"
               add_tag => [ "_missing_timestamp" ] }
    }

    # convert @timestamp to UNIX to use native kibana features
    date {
      id => "date_zeek_ts"
      match => [ "[zeek][ts]", "UNIX" ]
      target => "[@timestamp]"
    }

    # set firstPacket to timestamp, lastPacket to timestamp + duration
    # @timestamp is date type,
    # timestamp, firstPacket, lastPacket are UNIX epoch milliseconds
    ruby {
      id => "ruby_zeek_timestamp_calc"
      code => "event.set('[timestamp]', (1000*event.get('[zeek][ts]').to_f).round(0))
               event.set('[firstPacket]', event.get('[timestamp]'))"
    }
    if ([zeek_conn]) and ([zeek_conn][duration]) {
      # convert duration (floating-point seconds) to milliseconds
      ruby {
        id => "ruby_zeek_duration_calc"
        code => "event.set('[length]', (1000*event.get('[zeek_conn][duration]').to_f).round(0))
                 event.set('[lastPacket]', event.get('[timestamp]').to_i + event.get('[length]').to_i)"
      }
    } else {
      mutate { id => "mutate_add_field_zeek_lastPacket"
               add_field => { "[lastPacket]" => "%{timestamp}" } }
      mutate { id => "mutate_add_field_zeek_length"
               add_field => { "[length]" => "0" } }
    }

    # set the ts back as something more readable
    mutate { id => "mutate_replace_zeek_ts"
             replace => { "[zeek][ts]" => "%{[@timestamp]}" } }
  } # if ([zeek][ts])

  if ([srcIp]) {
    cidr {
      id      => "cidr_add_tag_internal_source"
      add_tag => [ "internal_source" ]
      address => [ "%{srcIp}" ]
      network => [ "0.0.0.0/8", "10.0.0.0/8", "100.64.0.0/10", "127.0.0.0/8", "169.254.0.0/16", "172.16.0.0/12", "192.0.0.0/24", "192.0.2.0/24",
                   "192.88.99.0/24", "192.168.0.0/16", "198.18.0.0/15", "198.51.100.0/24", "203.0.113.0/24", "224.0.0.0/4", "240.0.0.0/4",
                   "255.255.255.255/32", "::/0", "::/128", "::1/128", "fc00::/7", "fe80::/10", "ff00::/8"]
    }
    if (!("internal_source" in [tags])) {
      mutate { id => "mutate_add_tag_external_source"
               add_tag => [ "external_source" ] }
      # map srcIp to GEO countries
      geoip {
        id => "geoip_zeek_srcIp_geo"
        source => "[srcIp]"
        target => "[zeek][source_geo]"
      }
      geoip {
        id => "geoip_zeek_srcIp_asn"
        default_database_type => "ASN"
        source => "[srcIp]"
        target => "[@metadata][orig_asn]"
      }
      if ([zeek][source_geo] and [zeek][source_geo][country_code2]) {
        mutate { id => "mutate_add_field_zeek_srcGEO"
                 add_field => { "[srcGEO]" => "%{[zeek][source_geo][country_code2]}" } }
      }
      if ([@metadata][orig_asn] and [@metadata][orig_asn][as_org] and [@metadata][orig_asn][asn]) {
        mutate { id => "mutate_add_field_zeek_srcASN"
                 add_field => { "[srcASN]" => "AS%{[@metadata][orig_asn][asn]} %{[@metadata][orig_asn][as_org]}" } }
      }

      # if reverse DNS for public IP addresses is enabled (via environment variable) do it
      mutate {
        add_field => { "[@metadata][ENV_LOGSTASH_REVERSE_DNS]" => "${LOGSTASH_REVERSE_DNS:false}" }
      }
      if ([@metadata][ENV_LOGSTASH_REVERSE_DNS] == "true") {
        mutate {
          id => "mutate_add_field_srcip_for_dns"
          add_field => {
            "[zeek][source_ip_reverse_dns]" => "%{[srcIp]}"
          }
        }
        dns {
          id => "dns_source_ip_reverse_dns"
          reverse => [ "[zeek][source_ip_reverse_dns]" ]
          action => "replace"
          hit_cache_size => 8000
          hit_cache_ttl => 300
          failed_cache_size => 8000
          failed_cache_ttl => 60
        }
        if ([srcIp] == [zeek][source_ip_reverse_dns]) {
          mutate {
            id => "mutate_remove_field_source_ip_reverse_dns"
            remove_field => [ "[zeek][source_ip_reverse_dns]" ]
          }
        }
      }
    }
  } # if ([srcIp])

  if ([dstIp]) {
    cidr {
      id      => "cidr_add_tag_internal_destination"
      add_tag => [ "internal_destination" ]
      address => [ "%{dstIp}" ]
      network => [ "0.0.0.0/8", "10.0.0.0/8", "100.64.0.0/10", "127.0.0.0/8", "169.254.0.0/16", "172.16.0.0/12", "192.0.0.0/24", "192.0.2.0/24",
                   "192.88.99.0/24", "192.168.0.0/16", "198.18.0.0/15", "198.51.100.0/24", "203.0.113.0/24", "224.0.0.0/4", "240.0.0.0/4",
                   "255.255.255.255/32", "::/0", "::/128", "::1/128", "fc00::/7", "fe80::/10", "ff00::/8"]
    }
    if (!("internal_destination" in [tags])) {
      mutate { id => "mutate_add_tag_external_destination"
               add_tag => [ "external_destination" ] }
      # map dstIp to GEO countries
      geoip {
        id => "geoip_zeek_dstIp_geo"
        source => "[dstIp]"
        target => "[zeek][destination_geo]"
      }
      geoip {
        id => "geoip_zeek_dstIp_asn"
        default_database_type => "ASN"
        source => "[dstIp]"
        target => "[@metadata][resp_asn]"
      }
      if ([zeek][destination_geo] and [zeek][destination_geo][country_code2]) {
        mutate { id => "mutate_add_field_zeek_dstGEO"
                 add_field => { "[dstGEO]" => "%{[zeek][destination_geo][country_code2]}" } }
      }
      if ([@metadata][resp_asn] and [@metadata][resp_asn][as_org] and [@metadata][resp_asn][asn]) {
        mutate { id => "mutate_add_field_zeek_dstASN"
                 add_field => { "[dstASN]" => "AS%{[@metadata][resp_asn][asn]} %{[@metadata][resp_asn][as_org]}" } }
      }

      # if reverse DNS for public IP addresses is enabled (via environment variable) do it
      if (![@metadata][ENV_LOGSTASH_REVERSE_DNS]) {
        mutate {
          add_field => { "[@metadata][ENV_LOGSTASH_REVERSE_DNS]" => "${LOGSTASH_REVERSE_DNS:false}" }
        }
      }
      if ([@metadata][ENV_LOGSTASH_REVERSE_DNS] == "true") {
        mutate {
          id => "mutate_add_field_dstip_for_dns"
          add_field => {
            "[zeek][destination_ip_reverse_dns]" => "%{[dstIp]}"
          }
        }
        dns {
          id => "dns_destination_ip_reverse_dns"
          reverse => [ "[zeek][destination_ip_reverse_dns]" ]
          action => "replace"
          hit_cache_size => 8000
          hit_cache_ttl => 300
          failed_cache_size => 8000
          failed_cache_ttl => 60
        }
        if ([dstIp] == [zeek][destination_ip_reverse_dns]) {
          mutate {
            id => "mutate_remove_field_destination_ip_reverse_dns"
            remove_field => [ "[zeek][destination_ip_reverse_dns]" ]
          }
        }
      }

    }
  } # if ([dstIp])

  # set user and transport- and application-level protocols if specified
  if ([zeek][user]) {
    mutate { id => "mutate_split_zeek_user"
             split => { "[zeek][user]" => "," } }
    mutate { id => "mutate_merge_zeek_user"
             merge => { "[user]" => "[zeek][user]" } }
  }
  if ([zeek][proto]) {
    translate {
      id => "translate_zeek_proto"
      field => "[zeek][proto]"
      destination => "[ipProtocol]"
      dictionary_path => "/etc/ip_protocol_numbers.yaml"
    }
    mutate { id => "mutate_split_zeek_proto"
             split => { "[zeek][proto]" => "," } }
    mutate { id => "mutate_merge_zeek_proto"
             merge => { "[protocol]" => "[zeek][proto]" } }
  }
  if ([zeek][service]) {
    mutate { id => "mutate_split_zeek_service"
             split => { "[zeek][service]" => "," } }
    mutate { id => "mutate_merge_zeek_service"
             merge => { "[protocol]" => "[zeek][service]" } }
  }

  if ([source] == "conn") {
    #############################################################################################################################
    # conn.log specific logic

    translate {
      field => "[zeek_conn][conn_state]"

      destination => "[zeek_conn][conn_state_description]"

      dictionary => [ "S0", "Connection attempt seen, no reply",
                      "S1", "Connection established, not terminated",
                      "S2", "Connection established and close attempt by originator seen (but no reply from responder)",
                      "S3", "Connection established and close attempt by responder seen (but no reply from originator)",
                      "SF", "Normal SYN/FIN completion",
                      "REJ", "Connection attempt rejected",
                      "RSTO", "Connection established, originator aborted (sent a RST)",
                      "RSTR", "Established, responder aborted",
                      "RSTOS0", "Originator sent a SYN followed by a RST, we never saw a SYN-ACK from the responder",
                      "RSTRH", "Responder sent a SYN ACK followed by a RST, we never saw a SYN from the (purported) originator",
                      "SH", "Originator sent a SYN followed by a FIN, we never saw a SYN ACK from the responder (hence the connection was 'half' open)",
                      "SHR", "Responder sent a SYN ACK followed by a FIN, we never saw a SYN from the originator",
                      "OTH", "No SYN seen, just midstream traffic (a 'partial connection' that was not later closed)"]
    }

    mutate { id => "mutate_split_zeek_conn_tunnel_parents"
             split => { "[zeek_conn][tunnel_parents]" => "," } }

    if ([zeek_conn][vlan] or [zeek_conn][vlan]) {
      if ([zeek_conn][vlan]) {
        mutate { id => "mutate_merge_zeek_conn_vlan"
                 merge => { "[vlan]" => "[zeek_conn][vlan]" } }
      }
      if ([zeek_conn][inner_vlan]) {
        mutate { id => "mutate_merge_zeek_conn_inner_vlan"
                 merge => { "[vlan]" => "[zeek_conn][inner_vlan]" } }
      }
      ruby {
        id => "ruby_zeek_conn_vlanCnt"
        code => "event.set('[vlanCnt]', event.get('[vlan]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_conn_vlan"
        convert_datatype => {
          "[vlan]" => "int"
        }
      }
      dissect {
        id => "dissect_convert_datatype_zeek_conn_vlanCnt"
        convert_datatype => {
          "[vlanCnt]" => "int"
        }
      }
    }

    # aggregate total bytes and packets
    ruby {
      id => "ruby_zeek_bytes_and_packets_calc"
      code => "event.set('[totDataBytes]', event.get('[srcDataBytes]').to_i + event.get('[dstDataBytes]').to_i)
               event.set('[totBytes]', event.get('[srcBytes]').to_i + event.get('[dstBytes]').to_i)
               event.set('[totPackets]', event.get('[srcPackets]').to_i + event.get('[dstPackets]').to_i)"
    }

    if ([zeek_conn][history]) {
      ruby {
        id => "ruby_zeek_conn_history"
        # see https://www.zeek.org/sphinx/scripts/base/protocols/conn/main.bro.html#type-Conn::Info
        code => "historyStr = event.get('[zeek_conn][history]').upcase
                 sCnt = historyStr.count('S')
                 hCnt = historyStr.count('H')
                 aCnt = historyStr.count('A')
                 fCnt = historyStr.count('F')
                 rCnt = historyStr.count('R')
                 event.set('[tcpflags][syn]',     10**(sCnt-1)) if sCnt > 0
                 event.set('[tcpflags][syn-ack]', 10**(hCnt-1)) if hCnt > 0
                 event.set('[tcpflags][ack]',     10**(aCnt-1)) if aCnt > 0
                 event.set('[tcpflags][fin]',     10**(fCnt-1)) if fCnt > 0
                 event.set('[tcpflags][rst]',     10**(rCnt-1)) if rCnt > 0"
      }
    }

  } else if ([source] == "dhcp") {
    #############################################################################################################################
    # dhcp.log specific logic

    if ([zeek][orig_l2_addr]) {
      mutate {
        id => "mutate_add_fields_zeek_dhcp_mac"
        add_field => {
          "[zeek_dhcp][mac]" => "%{[zeek][orig_l2_addr]}"
        }
      }
      mutate { id => "mutate_merge_zeek_dhcp_mac"
               merge => { "[dhcp][mac]" => "[zeek][orig_l2_addr]" } }
      ruby {
        id => "ruby_zeek_dhcp_macCnt"
        code => "event.set('[dhcp][macCnt]', event.get('[dhcp][mac]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_dhcp_macCnt"
        convert_datatype => {
          "[dhcp][macCnt]" => "int"
        }
      }
      if ([srcOui]) {
        mutate {
          id => "mutate_add_fields_zeek_dhcp_oui"
          add_field => {
            "[dhcp][oui]" => "%{[srcOui]}"
          }
        }
        mutate {
          id => "mutate_add_fields_zeek_dhcp_ouiCnt"
          add_field => {
            "[dhcp][ouiCnt]" => "%{[srcOuiCnt]}"
          }
        }
        dissect {
          id => "dissect_convert_datatype_dhcp_ouiCnt"
          convert_datatype => {
            "[dhcp][ouiCnt]" => "int"
          }
        }
      }
    }

    if ([zeek_dhcp][msg_types]) {
      mutate { id => "mutate_split_zeek_dhcp_msg_types"
                 split => { "[zeek_dhcp][msg_types]" => "," } }
      mutate { id => "mutate_split_zeek_dhcp_type"
               merge => { "[dhcp][type]" => "[zeek_dhcp][msg_types]" } }
    }

    if ([zeek_dhcp][trans_id]) {
      mutate { id => "mutate_merge_zeek_dhcp_id"
               merge => { "[dhcp][id]" => "[zeek_dhcp][trans_id]" } }
      ruby {
        id => "ruby_zeek_dhcp_idCnt"
        code => "event.set('[dhcp][idCnt]', event.get('[dhcp][id]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_dhcp_idCnt"
        convert_datatype => {
          "[dhcp][idCnt]" => "int"
        }
      }
    }

    if ([zeek_dhcp][host_name]) {
      mutate { id => "mutate_merge_zeek_dhcp_host_name"
               merge => { "[dhcp][host]" => "[zeek_dhcp][host_name]" } }
    }

    if ([zeek_dhcp][assigned_ip]) {
      mutate { id => "mutate_merge_zeek_dhcp_host"
               merge => { "[dhcp][host]" => "[zeek_dhcp][assigned_ip]" } }
    }

    if ([dhcp][host]) {
      ruby {
        id => "ruby_zeek_dhcp_hostCnt"
        code => "event.set('[dhcp][hostCnt]', event.get('[dhcp][host]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_dhcp_hostCnt"
        convert_datatype => {
          "[dhcp][hostCnt]" => "int"
        }
      }
    }

  } else if ([source] == "dns") {
    #############################################################################################################################
    # dns.log specific logic

    # todo: adjust this regex so it at least sort of catches IPv6 as well
    # this must be done because [dns][ip] only handles IPv4 or IPv6 addresses
    # but [answers] can contain hostnames as well
    if ([zeek_dns][answers]) {
      ruby {
        id => "ruby_zeek_dns_answers_ip_extract"
        code => "event.set('[@metadata][answers_ip]', event.get('[zeek_dns][answers]').scan(/\d+\.\d+\.\d+\.\d+/).join(','))"
      }
      mutate { id => "mutate_split_zeek_dns_answers"
               split => { "[zeek_dns][answers]" => "," } }
      mutate { id => "mutate_split_zeek_dns_answers_ip"
               split => { "[@metadata][answers_ip]" => "," } }
    }
    mutate { id => "mutate_split_zeek_dns_TTLs"
               split => { "[zeek_dns][TTLs]" => "," } }

    if ([zeek_dns][query]) {
      mutate { id => "mutate_merge_zeek_query"
               merge => { "[dns][host]" => "[zeek_dns][query]" } }
      # seriously I do not get how merge works
      mutate { id => "mutate_add_field_zeek_opcode"
               add_field => { "[@metadata][opcode]" => "QUERY" } }
      mutate { id => "mutate_merge_zeek_opcode"
               merge => { "[dns][opcode]" => "[@metadata][opcode]" } }
    }
    if ([dns][host]) {
      ruby {
        id => "ruby_zeek_dns_hostCnt"
        code => "event.set('[dns][hostCnt]', event.get('[dns][host]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_dns_hostCnt"
        convert_datatype => {
          "[dns][hostCnt]" => "int"
        }
      }
    }
    if ([dns][opcode]) {
      ruby {
        id => "ruby_zeek_dns_opcodeCnt"
        code => "event.set('[dns][opcodeCnt]', event.get('[dns][opcode]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_dns_opcodeCnt"
        convert_datatype => {
          "[dns][opcodeCnt]" => "int"
        }
      }
    }

    if ([@metadata][answers_ip]) {
      mutate { id => "mutate_merge_zeek_dns_ip"
               merge => { "[dns][ip]" => "[@metadata][answers_ip]" } }
    }

    if ([zeek_dns][qclass_name]) {
      mutate { id => "mutate_merge_zeek_dns_qc"
               merge => { "[dns][qc]" => "[zeek_dns][qclass_name]" } }
      ruby {
        id => "ruby_zeek_dns_qcCnt"
        code => "event.set('[dns][qcCnt]', event.get('[dns][qc]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_dns_qcCnt"
        convert_datatype => {
          "[dns][qcCnt]" => "int"
        }
      }
    }

    if ([zeek_dns][qtype_name]) {
      mutate { id => "mutate_merge_zeek_dns_qt"
               merge => { "[dns][qt]" => "[zeek_dns][qtype_name]" } }
      ruby {
        id => "ruby_zeek_dns_qtCnt"
        code => "event.set('[dns][qtCnt]', event.get('[dns][qt]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_dns_qtCnt"
        convert_datatype => {
          "[dns][qtCnt]" => "int"
        }
      }
    }

    if ([dns][ip]) {
      ruby {
        id => "ruby_zeek_dns_ipCnt"
        code => "event.set('[dns][ipCnt]', event.get('[dns][ip]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_dns_ipCnt"
        convert_datatype => {
          "[dns][ipCnt]" => "int"
        }
      }

      if ([dns][ipCnt] > 0) {
        geoip {
          id => "geoip_zeek_dns_ip_asn"
          default_database_type => "ASN"
          source => "[dns][ip]"
          target => "[@metadata][dns_asn]"
        }
        if ([@metadata][dns_asn] and [@metadata][dns_asn][as_org] and [@metadata][dns_asn][asn]) {
          # this is stupid, the %{} doesn't seem to be liked by mutate.merge
          mutate { id => "mutate_add_field_zeek_dns_asn"
                   add_field => { "[@metadata][asn_str]" => "AS%{[@metadata][dns_asn][asn]} %{[@metadata][dns_asn][as_org]}" } }
          mutate { id => "mutate_merge_zeek_dns_asn"
                   merge => { "[dns][ASN]" => "[@metadata][asn_str]" } }
        }

        geoip {
          id => "geoip_zeek_dns_ip_geo"
          source => "[dns][ip]"
          target => "[@metadata][dns_geo]"
        }
        if ([@metadata][dns_geo] and [@metadata][dns_geo][country_code2]) {
          mutate { id => "mutate_merge_zeek_dns_geo"
                   merge => { "[dns][GEO]" => "[@metadata][dns_geo][country_code2]" } }
        }
      }
    } # if([dns][ip])

  } else if ([source] == "files") {
    #############################################################################################################################
    # files.log specific logic

    # collect all FUIDs under the parent [zeek][fuid] array
    if ([zeek_files][fuid]) {
      mutate { id => "mutate_split_zeek_files_fuid"
               split => { "[zeek_files][fuid]" => "," } }
      mutate { id => "mutate_merge_zeek_files_fuid"
               merge => { "[zeek][fuid]" => "[zeek_files][fuid]" } }
    }
    if ([zeek_files][parent_fuid]) {
      mutate { id => "mutate_split_zeek_files_parent_fuid"
               split => { "[zeek_files][parent_fuid]" => "," } }
      mutate { id => "mutate_merge_zeek_files_parent_fuid"
               merge => { "[zeek][fuid]" => "[zeek_files][parent_fuid]" } }
    }
    # collect all filenames under the parent [zeek][filename] array
    if ([zeek_files][filename]) { mutate { id => "mutate_merge_zeek_files_filename"
                                          merge => { "[zeek][filename]" => "[zeek_files][filename]" } } }
    # collect all mime types under the parent [zeek][filetype] array
    if ([zeek_files][mime_type]) { mutate { id => "mutate_merge_zeek_files_mime_type"
                                           merge => { "[zeek][filetype]" => "[zeek_files][mime_type]" } } }

    if ([zeek_files][total_bytes]) {
      ruby {
        id => "ruby_zeek_files_totBytes"
        code => "event.set('[totBytes]', event.get('[zeek_files][total_bytes]').to_i)"
      }
    }
    if ([zeek_files][seen_bytes]) {
      ruby {
        id => "ruby_zeek_files_totDataBytes"
        code => "event.set('[totDataBytes]', event.get('[zeek_files][seen_bytes]').to_i)"
      }
    }

    mutate { id => "mutate_split_zeek_files_analyzers"
             split => { "[zeek_files][analyzers]" => "," } }

  } else if ([source] == "ftp") {
    #############################################################################################################################
    # ftp.log specific logic

    if ([zeek_ftp][file_size]) {
      ruby {
        id => "ruby_zeek_ftp_totDataBytes"
        code => "event.set('[totDataBytes]', event.get('[zeek_ftp][file_size]').to_i)"
      }
    }

    # collect all FUIDs under the parent [zeek][fuid] array
    if ([zeek_ftp][fuid]) {
      mutate { id => "mutate_split_zeek_ftp_fuid"
               split => { "[zeek_ftp][fuid]" => "," } }
      mutate { id => "mutate_merge_zeek_ftp_fuid"
               merge => { "[zeek][fuid]" => "[zeek_ftp][fuid]" } }
    }

    # collect all mime types under the parent [zeek][filetype] array
    if ([zeek_ftp][mime_type]) { mutate { id => "mutate_merge_zeek_ftp_filetype"
                                         merge => { "[zeek][filetype]" => "[zeek_ftp][mime_type]" } } }

  } else if ([source] == "gquic") {
    #############################################################################################################################
    # gquic.log specific logic

    if ([zeek_gquic][user_agent]) {
      mutate { id => "mutate_merge_zeek_quic_useragent"
               merge => { "[quic][useragent]" => "[zeek_gquic][user_agent]" } }
      mutate {
        id => "mutate_add_field_zeek_quic_useragentCnt"
        add_field => {
          "[quic][useragentCnt]" => "1"
        }
      }
      dissect {
        id => "mutate_convert_field_zeek_quic_useragentCnt"
        convert_datatype => {
          "[quic][useragentCnt]" => "int"
        }
      }
    }

    if ([zeek_gquic][server_name]) {
      mutate { id => "mutate_merge_zeek_quic_host"
               merge => { "[quic][host]" => "[zeek_gquic][server_name]" } }
      mutate {
        id => "mutate_add_field_zeek_quic_hostCnt"
        add_field => {
          "[quic][hostCnt]" => "1"
        }
      }
      dissect {
        id => "mutate_convert_field_zeek_quic_hostCnt"
        convert_datatype => {
          "[quic][hostCnt]" => "int"
        }
      }
    }

    if ([zeek_gquic][version]) {
      ruby {
        id => "ruby_zeek_set_quic_version"
        code => "event.set('[quic][version]', 'Q' + event.get('[zeek_gquic][version]').rjust(3, '0'))"
      }
      mutate {
        id => "mutate_add_field_zeek_quic_versionCnt"
        add_field => {
          "[quic][versionCnt]" => "1"
        }
      }
      dissect {
        id => "mutate_convert_field_zeek_quic_versionCnt"
        convert_datatype => {
          "[quic][versionCnt]" => "int"
        }
      }
    }


  } else if ([source] == "http") {
    #############################################################################################################################
    # http.log specific logic

    mutate { id => "mutate_split_zeek_http_orig_fuids"
             split => { "[zeek_http][orig_fuids]" => "," } }
    mutate { id => "mutate_split_zeek_http_orig_filenames"
             split => { "[zeek_http][orig_filenames]" => "," } }
    mutate { id => "mutate_split_zeek_http_orig_mime_types"
             split => { "[zeek_http][orig_mime_types]" => "," } }
    mutate { id => "mutate_split_zeek_http_resp_fuids"
             split => { "[zeek_http][resp_fuids]" => "," } }
    mutate { id => "mutate_split_zeek_http_resp_filenames"
             split => { "[zeek_http][resp_filenames]" => "," } }
    mutate { id => "mutate_split_zeek_http_resp_mime_types"
             split => { "[zeek_http][resp_mime_types]" => "," } }
    mutate { id => "mutate_split_zeek_http_tags"
             split => { "[zeek_http][tags]" => "," } }
    mutate { id => "mutate_split_zeek_http_proxied"
             split => { "[zeek_http][proxied]" => "," } }

    if ([zeek_http][host]) {
      mutate { id => "mutate_merge_zeek_http_host"
               merge => { "[http][host]" => "[zeek_http][host]" } }
      ruby {
        id => "ruby_zeek_http_hostCnt"
        code => "event.set('[http][hostCnt]', event.get('[http][host]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_http_hostCnt"
        convert_datatype => {
          "[http][hostCnt]" => "int"
        }
      }
    }
    if ([zeek_http][uri]) {
      if ([zeek_http][host]) {
        mutate { id => "mutate_add_field_metadata_http_host_and_uri"
                 add_field => { "[@metadata][http_uri]" => "%{[zeek_http][host]}%{[zeek_http][uri]}" } }
        mutate { id => "mutate_merge_zeek_http_host_and_uri"
                 merge => { "[http][uri]" => "[@metadata][http_uri]" } }
      } else {
        mutate { id => "mutate_merge_zeek_http_uri"
                 merge => { "[http][uri]" => "[zeek_http][uri]" } }
      }
    } else if ([zeek_http][referrer]) {
      mutate { id => "mutate_merge_zeek_http_referrer"
      merge => { "[http][uri]" => "[zeek_http][referrer]" } }
    }
    if ([http][uri]) {
      ruby {
        id => "ruby_zeek_http_uriCnt"
        code => "event.set('[http][uriCnt]', event.get('[http][uri]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_http_uriCnt"
        convert_datatype => {
          "[http][uriCnt]" => "int"
        }
      }
    }
    if ([zeek_http][user_agent]) {
      mutate { id => "mutate_merge_zeek_http_user_agent"
               merge => { "[http][useragent]" => "[zeek_http][user_agent]" } }
      ruby {
        id => "ruby_zeek_http_useragentCnt"
        code => "event.set('[http][useragentCnt]', event.get('[http][useragent]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_http_useragentCnt"
        convert_datatype => {
          "[http][useragentCnt]" => "int"
        }
      }
    }
    if ([zeek_http][orig_mime_types]) {
      mutate { id => "mutate_merge_zeek_http_orig_mime_types"
               merge => { "[@metadata][mime_types]" => "[zeek_http][orig_mime_types]" } }
    }
    if ([zeek_http][resp_mime_types]) {
      mutate { id => "mutate_merge_zeek_http_resp_mime_types"
               merge => { "[@metadata][mime_types]" => "[zeek_http][resp_mime_types]" } }
    }
    if ([@metadata][mime_types]) {
      mutate { id => "mutate_merge_zeek_http_bodyMagic"
               merge => { "[http][bodyMagic]" => "[@metadata][mime_types]" } }
      ruby {
        id => "ruby_zeek_http_bodyMagicCnt"
        code => "event.set('[http][bodyMagicCnt]', event.get('[@metadata][mime_types]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_http_bodyMagicCnt"
        convert_datatype => {
          "[http][bodyMagicCnt]" => "int"
        }
      }
      # collect all mime types under the parent [zeek][filetype] array
      mutate { id => "mutate_merge_zeek_http_filetype"
               merge => { "[zeek][filetype]" => "[@metadata][mime_types]" } }
    }
    if ([zeek_http][version]) {
      mutate { id => "mutate_merge_zeek_http_clientVersion"
               merge => { "[http][clientVersion]" => "[zeek_http][version]" } }
      ruby {
        id => "ruby_zeek_http_clientVersionCnt"
        code => "event.set('[http][clientVersionCnt]', event.get('[http][clientVersion]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_http_clientVersionCnt"
        convert_datatype => {
          "[http][clientVersionCnt]" => "int"
        }
      }
    }
    if ([zeek_http][status_code]) {
      mutate { id => "mutate_merge_zeek_http_statuscode"
               merge => { "[http][statuscode]" => "[zeek_http][status_code]" } }
      ruby {
        id => "ruby_zeek_http_statuscodeCnt"
        code => "event.set('[http][statuscodeCnt]', event.get('[http][statuscode]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_http_statuscodeCnt"
        convert_datatype => {
          "[http][statuscodeCnt]" => "int"
        }
      }
    }
    if ([zeek_http][method]) {
      mutate { id => "mutate_merge_zeek_http_method"
               merge => { "[http][method]" => "[zeek_http][method]" } }
      ruby {
        id => "ruby_zeek_http_methodCnt"
        code => "event.set('[http][methodCnt]', event.get('[http][method]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_http_methodCnt"
        convert_datatype => {
          "[http][methodCnt]" => "int"
        }
      }
    }

    ruby {
      id => "ruby_zeek_http_totDataBytes"
      code => "event.set('[totDataBytes]', event.get('[zeek_http][response_body_len]').to_i + event.get('[zeek_http][request_body_len]').to_i)"
    }

    # collect all FUIDs under the parent [zeek][fuid] array
    if ([zeek_http][orig_fuids]) { mutate { id => "mutate_merge_zeek_http_orig_fuids_to_fuid"
                                           merge => { "[zeek][fuid]" => "[zeek_http][orig_fuids]" } } }
    if ([zeek_http][resp_fuids]) { mutate { id => "mutate_merge_zeek_resp_fuids_to_fuid"
                                           merge => { "[zeek][fuid]" => "[zeek_http][resp_fuids]" } } }

    # collect all filenames under the parent [zeek][filename] array
    if ([zeek_http][orig_filenames]) { mutate { id => "mutate_merge_zeek_http_orig_filenames_to_filename"
                                               merge => { "[zeek][filename]" => "[zeek_http][orig_filenames]" } } }
    if ([zeek_http][resp_filenames]) { mutate { id => "mutate_merge_zeek_http_resp_filenames_to_filename"
                                               merge => { "[zeek][filename]" => "[zeek_http][resp_filenames]" } } }


  } else if ([source] == "irc") {
    #############################################################################################################################
    # irc.log specific logic

    # collect all FUIDs under the parent [zeek][fuid] array
    if ([zeek_irc][fuid]) {
      mutate { id => "mutate_split_zeek_irc_fuid"
               split => { "[zeek_irc][fuid]" => "," } }
      mutate { id => "mutate_merge_zeek_irc_fuid"
               merge => { "[zeek][fuid]" => "[zeek_irc][fuid]" } }
    }

    # collect all filenames under the parent [zeek][filename] array
    if ([zeek_irc][dcc_file_name]) { mutate { id => "mutate_merge_zeek_irc_filename"
                                             merge => { "[zeek][filename]" => "[zeek_irc][dcc_file_name]" } } }

    # collect all mime types under the parent [zeek][filetype] array
    if ([zeek_irc][dcc_mime_type]) { mutate { id => "mutate_merge_zeek_irc_filetype"
                                             merge => { "[zeek][filetype]" => "[zeek_irc][dcc_mime_type]" } } }

    if ([zeek_irc][nick]) {
      mutate { id => "mutate_merge_zeek_irc_nick"
               merge => { "[irc][nick]" => "[zeek_irc][nick]" } }
      ruby {
        id => "ruby_zeek_irc_nickCnt"
        code => "event.set('[irc][nickCnt]', event.get('[irc][nick]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_irc_nickCnt"
        convert_datatype => {
          "[irc][nickCnt]" => "int"
        }
      }
    }

    if ([zeek_irc][command]) and ([zeek_irc][value]) and (([zeek_irc][command] == "JOIN") or ([zeek_irc][command] == "PART")) {
      mutate { id => "mutate_merge_zeek_irc_channel"
               merge => { "[irc][channel]" => "[zeek_irc][value]" } }
      ruby {
        id => "ruby_zeek_irc_channelCnt"
        code => "event.set('[irc][channelCnt]', event.get('[irc][channel]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_irc_channelCnt"
        convert_datatype => {
          "[irc][channelCnt]" => "int"
        }
      }
    }

  } else if ([source] == "intel") {
    #############################################################################################################################
    # intel.log specific logic

    if ([zeek_intel][sources]) {
      mutate { id => "mutate_split_zeek_intel_sources"
               split => { "[zeek_intel][sources]" => "," } }
    }

    # collect all FUIDs under the parent [zeek][fuid] array
    if ([zeek_intel][fuid]) {
      mutate { id => "mutate_split_zeek_intel_fuid"
               split => { "[zeek_intel][fuid]" => "," } }
      mutate { id => "mutate_merge_zeek_intel_fuid"
               merge => { "[zeek][fuid]" => "[zeek_intel][fuid]" } }
    }

    # collect all mime types under the parent [zeek][filetype] array
    if ([zeek_intel][file_mime_type]) { mutate { id => "mutate_merge_zeek_intel_filetype"
                                                merge => { "[zeek][filetype]" => "[zeek_intel][file_mime_type]" } } }


  } else if ([source] == "kerberos") {
    #############################################################################################################################
    # kerberos.log specific logic

    if ([zeek_kerberos][cname]) {
      mutate { id => "mutate_merge_zeek_kerberos_cname"
               merge => { "[krb5][cname]" => "[zeek_kerberos][cname]" } }
      ruby {
        id => "ruby_zeek_kerberos_cnameCnt"
        code => "event.set('[krb5][cnameCnt]', event.get('[krb5][cname]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_kerberos_cnameCnt"
        convert_datatype => {
          "[krb5][cnameCnt]" => "int"
        }
      }
    }
    if ([zeek_kerberos][sname]) {
      mutate { id => "mutate_merge_zeek_kerberos_sname"
               merge => { "[krb5][sname]" => "[zeek_kerberos][sname]" } }
      ruby {
        id => "ruby_zeek_kerberos_snameCnt"
        code => "event.set('[krb5][snameCnt]', event.get('[krb5][sname]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_kerberos_snameCnt"
        convert_datatype => {
          "[krb5][snameCnt]" => "int"
        }
      }
    }

    if ([zeek_kerberos][from]) {
      date {
        id => "date_zeek_kerberos_from"
        match => [ "[zeek_kerberos][from]", "UNIX" ]
        target => "[@metadata][krb_time_from]"
      }
      if ([@metadata][krb_time_from]) { mutate { id => "mutate_replace_zeek_kerberos_from"
                                          replace => { "[zeek_kerberos][from]" => "%{[@metadata][krb_time_from]}" } } }
    }
    if ([zeek_kerberos][till]) {
      date {
        id => "date_zeek_kerberos_till"
        match => [ "[zeek_kerberos][till]", "UNIX" ]
        target => "[@metadata][krb_time_till]"
      }
      if ([@metadata][krb_time_till]) { mutate { id => "mutate_replace_zeek_kerberos_till"
                                          replace => { "[zeek_kerberos][till]" => "%{[@metadata][krb_time_till]}" } } }
    }

    # collect all FUIDs under the parent [zeek][fuid] array
    if ([zeek_kerberos][client_cert_fuid]) {
      mutate { id => "mutate_split_zeek_kerberos_client_cert_fuid"
               split => { "[zeek_kerberos][client_cert_fuid]" => "," } }
      mutate { id => "mutate_merge_zeek_kerberos_client_cert_fuid"
               merge => { "[@metadata][cert_fuids]" => "[zeek_kerberos][client_cert_fuid]" } }
    }
    if ([zeek_kerberos][server_cert_fuid]) {
      mutate { id => "mutate_split_zeek_kerberos_server_cert_fuid"
               split => { "[zeek_kerberos][server_cert_fuid]" => "," } }
      mutate { id => "mutate_merge_zeek_kerberos_server_cert_fuid"
               merge => { "[@metadata][cert_fuids]" => "[zeek_kerberos][server_cert_fuid]" } }
    }
    if ([@metadata][cert_fuids]) {
      mutate { id => "mutate_merge_zeek_kerberos_fuids_to_fuid"
               merge => { "[zeek][fuid]" => "[@metadata][cert_fuids]" } }
    }

  } else if ([source] == "notice") {
    #############################################################################################################################
    # notice.log specific logic
    mutate { id => "mutate_split_zeek_notice_actions"
             split => { "[zeek_notice][actions]" => "," } }

    # collect all FUIDs under the parent [zeek][fuid] array
    if ([zeek_notice][fuid]) {
      mutate { id => "mutate_split_zeek_notice_fuid"
               split => { "[zeek_notice][fuid]" => "," } }
      mutate { id => "mutate_merge_zeek_notice_fuid"
               merge => { "[zeek][fuid]" => "[zeek_notice][fuid]" } }
    }
    # collect all mime types under the parent [zeek][filetype] array
    if ([zeek_notice][file_mime_type]) { mutate { id => "mutate_merge_zeek_notice_filetype"
                                                 merge => { "[zeek][filetype]" => "[zeek_notice][file_mime_type]" } } }

  } else if ([source] == "pe") {
    #############################################################################################################################
    # pe.log specific logic

    mutate { id => "mutate_split_zeek_pe_section_names"
             split => { "[zeek_pe][section_names]" => "," } }

    if ([zeek_pe][compile_ts]) {
      date {
        id => "date_zeek_pe_compile_ts"
        match => [ "[zeek_pe][compile_ts]", "UNIX" ]
        target => "[@metadata][pe_time]"
      }
      if ([@metadata][pe_time]) { mutate { id => "mutate_replace_zeek_pe_compile_ts"
                                    replace => { "[zeek_pe][compile_ts]" => "%{[@metadata][pe_time]}" } } }
    }

    # collect all FUIDs under the parent [zeek][fuid] array
    if ([zeek_pe][fuid]) {
      mutate { id => "mutate_split_zeek_pe_fuid"
               split => { "[zeek_pe][fuid]" => "," } }
      mutate { id => "mutate_merge_zeek_pe_fuid"
               merge => { "[zeek][fuid]" => "[zeek_pe][fuid]" } }
    }

  } else if ([source] == "radius") {
    #############################################################################################################################
    # radius.log specific logic

    if ([zeek][user]) { mutate { id => "mutate_merge_zeek_radius_user"
                                merge => { "[radius][user]" => "[zeek][user]" } } }

    if ([zeek_radius][framed_addr]) {
      mutate { id => "mutate_merge_zeek_radius_framed_addr"
               merge => { "[radius][framedIp]" => "[zeek_radius][framed_addr]" } }
      ruby {
        id => "ruby_zeek_radius_framedIpCnt"
        code => "event.set('[radius][framedIpCnt]', event.get('[radius][framedIp]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_radius_framedIpCnt"
        convert_datatype => {
          "[radius][framedIpCnt]" => "int"
        }
      }
    }

    if ([zeek_radius][remote_ip]) {
      mutate { id => "mutate_merge_zeek_radius_remote_ip"
               merge => { "[radius][endpointIp]" => "[zeek_radius][remote_ip]" } }
      ruby {
        id => "ruby_zeek_radius_endpointIpCnt"
        code => "event.set('[radius][endpointIpCnt]', event.get('[radius][endpointIp]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_radius_endpointIpCnt"
        convert_datatype => {
          "[radius][endpointIpCnt]" => "int"
        }
      }
    }

    if ([zeek_radius][mac]) {
      mutate { id => "mutate_merge_zeek_radius_mac"
               merge => { "[radius][mac]" => "[zeek_radius][mac]" } }
      ruby {
        id => "ruby_zeek_radius_macCnt"
        code => "event.set('[radius][macCnt]', event.get('[radius][mac]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_radius_macCnt"
        convert_datatype => {
          "[radius][macCnt]" => "int"
        }
      }
    }

    if ([radius][framedIpCnt]) and ([radius][framedIpCnt] > 0) {
      geoip {
        default_database_type => "ASN"
        source => "[radius][framedIp]"
        target => "[@metadata][radius_asn]"
      }
      if ([@metadata][radius_asn] and [@metadata][radius_asn][as_org] and [@metadata][radius_asn][asn]) {
        # this is stupid, the %{} doesn't seem to be liked by mutate.merge
        mutate { id => "mutate_add_field_zeek_radius_asn"
                 add_field => { "[@metadata][asn_str]" => "AS%{[@metadata][radius_asn][asn]} %{[@metadata][radius_asn][as_org]}" } }
        mutate { id => "mutate_merge_zeek_radius_asn"
                 merge => { "[radius][framedASN]" => "[@metadata][asn_str]" } }
      }

      geoip {
        source => "[radius][framedIp]"
        target => "[@metadata][radius_geo]"
      }
      if ([@metadata][radius_geo] and [@metadata][radius_geo][country_code2]) {
        mutate { id => "mutate_merge_zeek_radius_geo"
                 merge => { "[radius][framedGEO]" => "[@metadata][radius_geo][country_code2]" } }
      }
    }

    if ([radius][endpointIpCnt]) and ([radius][endpointIpCnt] > 0) {
      geoip {
        default_database_type => "ASN"
        source => "[radius][endpointIp]"
        target => "[@metadata][radius_asn]"
      }
      if ([@metadata][radius_asn] and [@metadata][radius_asn][as_org] and [@metadata][radius_asn][asn]) {
        # this is stupid, the %{} doesn't seem to be liked by mutate.merge
        mutate { id => "mutate_add_field_zeek_radius_endpoint_asn"
                 add_field => { "[@metadata][asn_str]" => "AS%{[@metadata][radius_asn][asn]} %{[@metadata][radius_asn][as_org]}" } }
        mutate { id => "mutate_merge_zeek_radius_endpoint_asn"
                 merge => { "[radius][endpointASN]" => "[@metadata][asn_str]" } }
      }

      geoip {
        source => "[radius][endpointIp]"
        target => "[@metadata][radius_geo]"
      }
      if ([@metadata][radius_geo] and [@metadata][radius_geo][country_code2]) {
        mutate { id => "mutate_merge_zeek_radius_endpoint_geo"
                 merge => { "[radius][endpointGEO]" => "[@metadata][radius_geo][country_code2]" } }
      }
    }

  } else if ([source] == "signatures") {
    #############################################################################################################################
    # signatures.log specific logic

    if ("_carved" in [tags]) {
      # we're doing some "special" stuff in zeek-carve-monitor.py for file carving, sort of hijacking signatures.log for it

      if ([zeek_signatures][sub_message]) {
        # sub_message contains fuid(s) comma-separated
        mutate { id => "mutate_split_zeek_signatures_sub_message"
                 split => { "[zeek_signatures][sub_message]" => "," } }
        mutate { id => "mutate_merge_zeek_signatures_fuid"
                 merge => { "[zeek][fuid]" => "[zeek_signatures][sub_message]" } }
      }

      if ([zeek_signatures][event_message]) {
        # sub_message contains "Signature [Engine]" list semi-colon separated
        ruby {
            id => "ruby_zeek_signatures_event_message_parse"
            code => "
                matchesHash = Hash.new
                idArray = Array.new
                engineArray = Array.new
                event.get('[zeek_signatures][event_message]').split(';').each { |hit|
                  nameAndEngines = hit.split(/(.+?)\s*<(.+)>/)
                  nameAndEngines[2].split(',').each { |engine|
                    matchesHash[engine] = nameAndEngines[1]
                  }
                }
                event.set('[zeek_signatures][signature_id]', matchesHash.values.uniq)
                event.set('[zeek_signatures][engine]', matchesHash.keys)
                event.set('[zeek_signatures][hits]', matchesHash)"
        }
        mutate {
          id => "mutate_remove_field_zeek_signatures_event_message"
          remove_field => [ "[zeek_signatures][event_message]" ]
        }
      }

    } # _carved

    # signature_count is the number of hits
    if ([zeek_signatures][signature_count]) {
      dissect {
        id => "dissect_convert_datatype_zeek_signatures_signature_count"
        convert_datatype => {
          "[zeek_signatures][signature_count]" => "int"
        }
      }
    }

    # signature_count is the number of engines which scanned the file
    if ([zeek_signatures][host_count]) {
      dissect {
        id => "dissect_convert_datatype_zeek_signatures_host_count"
        convert_datatype => {
          "[zeek_signatures][host_count]" => "int"
        }
      }
    }

  } else if ([source] == "sip") {
    #############################################################################################################################
    # sip.log specific logic

    mutate { id => "mutate_split_zeek_sip_request_path"
             split => { "[zeek_sip][request_path]" => "," } }
    mutate { id => "mutate_split_zeek_sip_response_path"
             split => { "[zeek_sip][response_path]" => "," } }

  } else if ([source] == "smb_files") {
    #############################################################################################################################
    # smb_files.log specific logic

    # collect all FUIDs under the parent [zeek][fuid] array
    if ([zeek_smb_files][fuid]) {
      mutate { id => "mutate_split_zeek_smb_files_fuid"
               split => { "[zeek_smb_files][fuid]" => "," } }
      mutate { id => "mutate_merge_zeek_smb_files_fuid"
               merge => { "[zeek][fuid]" => "[zeek_smb_files][fuid]" } }
    }
    # collect all filenames under the parent [zeek][filename] array
    if ([zeek_smb_files][name]) { mutate { id => "mutate_merge_zeek_smb_files_name_to_filename"
                                          merge => { "[zeek][filename]" => "[zeek_smb_files][name]" } } }
    if ([zeek_smb_files][prev_name]) { mutate { id => "mutate_merge_zeek_smb_files_prev_name_to_filename"
                                               merge => { "[zeek][filename]" => "[zeek_smb_files][prev_name]" } } }

    if ([zeek][filename]) {
      mutate { id => "mutate_merge_zeek_smb_files_filename"
               merge => { "[smb][filename]" => "[zeek][filename]" } }
      ruby {
        id => "ruby_zeek_smb_files_filenameCnt"
        code => "event.set('[smb][filenameCnt]', event.get('[smb][filename]').length)"
      }
    }

    if ([zeek_smb_files][path]) {
      grok {
        id => "grok_zeek_smb_files_path"
        match => { "[zeek_smb_files][path]" => [ "^%{SPACE}[\\\/]+%{DATA:[@metadata][smb_host]}[\\\/]+%{DATA:[@metadata][smb_share]}(?:[\\\/]+%{GREEDYDATA:[@metadata][smb_path]})?$" ] }
      }
      if ([@metadata][smb_host]) {
        mutate { id => "mutate_merge_zeek_smb_files_host"
                 merge => { "[smb][host]" => "[@metadata][smb_host]" } }
        ruby {
          id => "ruby_zeek_smb_files_hostCnt"
          code => "event.set('[smb][hostCnt]', event.get('[smb][host]').length)"
        }
      }
      if ([@metadata][smb_share]) {
        mutate { id => "mutate_merge_zeek_smb_files_share"
                 merge => { "[smb][share]" => "[@metadata][smb_share]" } }
        ruby {
          id => "ruby_zeek_smb_files_shareCnt"
          code => "event.set('[smb][shareCnt]', event.get('[smb][share]').length)"
        }
      }
    }

    # convert times to something more usable
    if ([zeek_smb_files][times_modified]) {
      date {
        id => "date_zeek_smb_files_times_modified"
        match => [ "[zeek_smb_files][times_modified]", "UNIX" ]
        target => "[@metadata][smb_time_mod]"
      }
      if ([@metadata][smb_time_mod]) { mutate { id => "mutate_replace_zeek_smb_files_times_modified"
                                         replace => { "[zeek_smb_files][times_modified]" => "%{[@metadata][smb_time_mod]}" } } }
    }
    if ([zeek_smb_files][times_accessed]) {
      date {
        id => "date_zeek_smb_files_times_accessed"
        match => [ "[zeek_smb_files][times_accessed]", "UNIX" ]
        target => "[@metadata][smb_time_acc]"
      }
      if ([@metadata][smb_time_acc]) { mutate { id => "mutate_replace_zeek_smb_files_times_accessed"
                                         replace => { "[zeek_smb_files][times_accessed]" => "%{[@metadata][smb_time_acc]}" } } }
    }
    if ([zeek_smb_files][times_created]) {
      date {
        id => "date_zeek_smb_files_times_created"
        match => [ "[zeek_smb_files][times_created]", "UNIX" ]
        target => "[@metadata][smb_time_cre]"
      }
      if ([@metadata][smb_time_cre]) { mutate { id => "mutate_replace_zeek_smb_files_times_created"
                                         replace => { "[zeek_smb_files][times_created]" => "%{[@metadata][smb_time_cre]}" } } }
    }
    if ([zeek_smb_files][times_changed]) {
      date {
        id => "date_zeek_smb_files_times_changed"
        match => [ "[zeek_smb_files][times_changed]", "UNIX" ]
        target => "[@metadata][smb_time_cha]"
      }
      if ([@metadata][smb_time_cha]) { mutate { id => "mutate_replace_zeek_smb_files_times_changed"
                                         replace => { "[zeek_smb_files][times_changed]" => "%{[@metadata][smb_time_cha]}" } } }
    }

  } else if ([source] == "smb_mapping") {
    #############################################################################################################################
    # smb_mapping.log specific logic

    if ([zeek_smb_mapping][path]) {
      # todo: figure out how to replace \\ -> \
      mutate { id => "mutate_merge_zeek_smb_mapping_share"
               merge => { "[smb][share]" => "[zeek_smb_mapping][path]" } }
      ruby {
        id => "ruby_zeek_smb_mapping_shareCnt_orig"
        code => "event.set('[smb][shareCnt]', event.get('[smb][share]').length)"
      }
    }

    if ([zeek_smb_mapping][path]) {
      grok {
        id => "grok_zeek_smb_mapping_path"
        match => { "[zeek_smb_mapping][path]" => [ "^%{SPACE}[\\\/]+%{DATA:[@metadata][smb_host]}[\\\/]+%{DATA:[@metadata][smb_share]}(?:[\\\/]+%{GREEDYDATA:[@metadata][smb_path]})?$" ] }
      }
      if ([@metadata][smb_host]) {
        mutate { id => "mutate_merge_zeek_smb_mapping_host"
                 merge => { "[smb][host]" => "[@metadata][smb_host]" } }
        ruby {
          id => "ruby_zeek_smb_mapping_hostCnt"
          code => "event.set('[smb][hostCnt]', event.get('[smb][host]').length)"
        }
      }
      if ([@metadata][smb_share]) {
        mutate { id => "mutate_merge_zeek_smb_mapping_share_from_path"
                 merge => { "[smb][share]" => "[@metadata][smb_share]" } }
        ruby {
          id => "ruby_zeek_smb_mapping_shareCnt"
          code => "event.set('[smb][shareCnt]', event.get('[smb][share]').length)"
        }
      }
    }

  } else if ([source] == "smtp") {
    #############################################################################################################################
    # smtp.log specific logic

    mutate { id => "mutate_split_zeek_smtp_rcptto"
             split => { "[zeek_smtp][rcptto]" => "," } }
    mutate { id => "mutate_split_zeek_smtp_to"
             split => { "[zeek_smtp][to]" => "," } }
    mutate { id => "mutate_split_zeek_smtp_cc"
             split => { "[zeek_smtp][cc]" => "," } }

    # collect all FUIDs under the parent [zeek][fuid] array
    if ([zeek_smtp][fuids]) {
      mutate { id => "mutate_split_zeek_smtp_fuids"
               split => { "[zeek_smtp][fuids]" => "," } }
      mutate { id => "mutate_merge_zeek_smtp_fuids"
               merge => { "[zeek][fuid]" => "[zeek_smtp][fuids]" } }
    }

    if ([zeek_smtp][user_agent]) {
      mutate { id => "mutate_merge_zeek_smtp_user_agent"
               merge => { "[email][useragent]" => "[zeek_smtp][user_agent]" } }
      ruby {
        id => "ruby_zeek_smtp_useragentCnt"
        code => "event.set('[email][useragentCnt]', event.get('[email][useragent]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_smtp_useragentCnt"
        convert_datatype => {
          "[email][useragentCnt]" => "int"
        }
      }
    }

    if ([zeek_smtp][from]) { mutate { id => "mutate_merge_zeek_smtp_from"
                                     merge => { "[email][src]" => "[zeek_smtp][from]" } } }
    if ([zeek_smtp][mailfrom]) { mutate { id => "mutate_merge_zeek_smtp_mailfrom"
                                         merge => { "[email][src]" => "[zeek_smtp][mailfrom]" } } }
    if ([zeek_smtp][reply_to]) { mutate { id => "mutate_merge_zeek_smtp_reply_to"
                                         merge => { "[email][src]" => "[zeek_smtp][reply_to]" } } }
    if ([email][src]) {
      # mutate { id => "mutate_gsub_zeek_smtp_src"
      #          gsub => [ "[email][src]", "(^<|>$)", "" ] }
      ruby {
        id => "ruby_zeek_smtp_src"
        code => "event.set('[email][src]', event.get('[email][src]').uniq)
                 event.set('[email][srcCnt]', event.get('[email][src]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_smtp_srcCnt"
        convert_datatype => {
          "[email][srcCnt]" => "int"
        }
      }
    }

    if ([zeek_smtp][to]) { mutate { id => "mutate_merge_zeek_smtp_dst_from_to"
                                   merge => { "[email][dst]" => "[zeek_smtp][to]" } } }
    if ([zeek_smtp][cc]) { mutate { id => "mutate_merge_zeek_smtp_dst_from_cc"
                                   merge => { "[email][dst]" => "[zeek_smtp][cc]" } } }
    if ([zeek_smtp][rcptto]) { mutate { id => "mutate_merge_zeek_dst_from_rcptto"
                                       merge => { "[email][dst]" => "[zeek_smtp][rcptto]" } } }
    if ([email][dst]) {
      # mutate { id => "mutate_gsub_zeek_dst"
      #          gsub => [ "[email][dst]", "(^<|>$)", "" ] }
      ruby {
        id => "ruby_zeek_smtp_dst"
        code => "event.set('[email][dst]', event.get('[email][dst]').uniq)
                 event.set('[email][dstCnt]', event.get('[email][dst]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_smtp_dstCnt"
        convert_datatype => {
          "[email][dstCnt]" => "int"
        }
      }
    }

    if ([zeek_smtp][subject]) {
      mutate { id => "mutate_merge_zeek_smtp_subject"
               merge => { "[email][subject]" => "[zeek_smtp][subject]" } }
      ruby {
        id => "ruby_zeek_smtp_subjectCnt"
        code => "event.set('[email][subjectCnt]', event.get('[email][subject]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_smtp_subjectCnt"
        convert_datatype => {
          "[email][subjectCnt]" => "int"
        }
      }
    }

    if ([zeek_smtp][msg_id]) {
      mutate { id => "mutate_gsub_zeek_smtp_msg_id"
               gsub => [ "[zeek_smtp][msg_id]", "(^<|>$)", "" ] }
      mutate { id => "mutate_merge_zeek_smtp_msg_id"
               merge => { "[email][id]" => "[zeek_smtp][msg_id]" } }
    }
    if ([zeek_smtp][in_reply_to]) {
      mutate { id => "mutate_gsub_zeek_smtp_in_reply_to"
               gsub => [ "[zeek_smtp][in_reply_to]", "(^<|>$)", "" ] }
      mutate { id => "mutate_merge_zeek_smtp_in_reply_to"
               merge => { "[email][id]" => "[zeek_smtp][in_reply_to]" } }
    }
    if ([zeek_smtp][id]) {
      ruby {
        id => "ruby_zeek_smtp_idCnt"
        code => "event.set('[email][idCnt]', event.get('[email][id]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_smtp_idCnt"
        convert_datatype => {
          "[email][idCnt]" => "int"
        }
      }
    }

  } else if ([source] == "snmp") {
    #############################################################################################################################
    # snmp.log specific logic

    if ([zeek_snmp][up_since]) {
      date {
        id => "date_zeek_snmp_up_since"
        match => [ "[zeek_snmp][up_since]", "UNIX" ]
        target => "[@metadata][snmp_time]"
      }
      if ([@metadata][snmp_time]) { mutate { id => "mutate_replace_zeek_snmp_up_since"
                                      replace => { "[zeek_snmp][up_since]" => "%{[@metadata][snmp_time]}" } } }
    }

  } else if ([source] == "ssh") {
    #############################################################################################################################
    # ssh.log specific logic

    if ([zeek_ssh][server]) { mutate { id => "mutate_merge_zeek_ssh_server_version"
                                      merge => { "[ssh][version]" => "[zeek_ssh][server]" } } }
    if ([zeek_ssh][client]) { mutate { id => "mutate_merge_zeek_client_version"
                                      merge => { "[ssh][version]" => "[zeek_ssh][client]" } } }
    if (![ssh][version]) and ([zeek_ssh][version]) {
      mutate { id => "mutate_merge_zeek_ssh_version"
               merge => { "[ssh][version]" => "[zeek_ssh][version]" } }
    }
    if ([ssh][version]) {
      ruby {
        id => "ruby_zeek_ssh_versionCnt"
        code => "event.set('[ssh][versionCnt]', event.get('[ssh][version]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_ssh_versionCnt"
        convert_datatype => {
          "[ssh][versionCnt]" => "int"
        }
      }
    }

    if ([zeek_ssh][host_key] and [zeek_ssh][host_key_alg]) {
      # this is stupid, the %{} doesn't seem to be liked by mutate.merge
      mutate { id => "mutate_add_field_zeek_ssh_host_key"
               add_field => { "[@metadata][ssh_key_str]" => "%{[zeek_ssh][host_key_alg]} %{[zeek_ssh][host_key]}" } }
      mutate { id => "mutate_merge_zeek_ssh_key"
               merge => { "[ssh][key]" => "[@metadata][ssh_key_str]" } }
      ruby {
        id => "ruby_zeek_ssh_keyCnt"
        code => "event.set('[ssh][keyCnt]', event.get('[ssh][key]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_ssh_keyCnt"
        convert_datatype => {
          "[ssh][keyCnt]" => "int"
        }
      }
    }

    # HASSH stuff (see https://github.com/salesforce/hassh/tree/master/bro)

    if ([zeek_ssh][hassh]) {
      mutate {
        id => "mutate_merge_zeek_ssh_hassh"
        merge => {
          "[ssh][hassh]" => "[zeek_ssh][hassh]"
        }
      }
      mutate {
        id => "mutate_add_field_zeek_ssh_hasshCnt"
        add_field => {
          "[ssh][hasshCnt]" => "1"
        }
      }
      dissect {
        id => "mutate_convert_field_zeek_ssh_hasshCnt"
        convert_datatype => {
          "[ssh][hasshCnt]" => "int"
        }
      }
    }

    if ([zeek_ssh][hasshServer]) {
      mutate {
        id => "mutate_merge_zeek_ssh_hasshServer"
        merge => {
          "[ssh][hasshServer]" => "[zeek_ssh][hasshServer]"
        }
      }
      mutate {
        id => "mutate_add_field_zeek_ssh_hasshServerCnt"
        add_field => {
          "[ssh][hasshServerCnt]" => "1"
        }
      }
      dissect {
        id => "mutate_convert_field_zeek_ssh_hasshServerCnt"
        convert_datatype => {
          "[ssh][hasshServerCnt]" => "int"
        }
      }
    }

    if ([zeek_ssh][hasshAlgorithms]) { mutate { id => "mutate_split_zeek_ssh_hasshAlgorithms"
                                                split => { "[zeek_ssh][hasshAlgorithms]" => "," } } }

    if ([zeek_ssh][hasshServerAlgorithms]) { mutate { id => "mutate_split_zeek_ssh_hasshServerAlgorithms"
                                                      split => { "[zeek_ssh][hasshServerAlgorithms]" => "," } } }

    if ([zeek_ssh][cshka]) { mutate { id => "mutate_split_zeek_ssh_cshka"
                                      split => { "[zeek_ssh][cshka]" => "," } } }

    if ([zeek_ssh][sshka]) { mutate { id => "mutate_split_zeek_ssh_sshka"
                                      split => { "[zeek_ssh][sshka]" => "," } } }


  } else if ([source] == "ssl") {
    #############################################################################################################################
    # ssl.log specific logic

    # split subjects/issuers out into hashes
    # 1. handle escaped commans (urlencode)
    # 2. rename source hashes into metadata for splitting
    # 3. split fields by comma into destination hashes
    # 4. urldecode any commas we might have had

    if ([zeek_ssl][subject]) {
      mutate { id => "mutate_gsub_zeek_ssl_subject"
               gsub => [ "[zeek_ssl][subject]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_subject"
               rename => { "[zeek_ssl][subject]" => "[zeek_ssl][subject_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_subject"
        field_split => ","
        source => "[zeek_ssl][subject_full]"
        target => "[zeek_ssl][subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_subject"
        field => "[zeek_ssl][subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_subject_full"
        field => "[zeek_ssl][subject_full]"
      }
    }

    if ([zeek_ssl][client_subject]) {
      mutate { id => "mutate_gsub_zeek_ssl_client_subject"
               gsub => [ "[zeek_ssl][client_subject]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_client_subject"
               rename => { "[zeek_ssl][client_subject]" => "[zeek_ssl][client_subject_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_client_subject"
        field_split => ","
        source => "[zeek_ssl][client_subject_full]"
        target => "[zeek_ssl][client_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_subject"
        field => "[zeek_ssl][client_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_subject_full"
        field => "[zeek_ssl][client_subject_full]"
      }
    }

    if ([zeek_ssl][issuer]) {
      mutate { id => "mutate_gsub_zeek_ssl_issuer"
               gsub => [ "[zeek_ssl][issuer]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_issuer"
               rename => { "[zeek_ssl][issuer]" => "[zeek_ssl][issuer_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_issuer"
        field_split => ","
        source => "[zeek_ssl][issuer_full]"
        target => "[zeek_ssl][issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_issuer"
        field => "[zeek_ssl][issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_issuer_full"
        field => "[zeek_ssl][issuer_full]"
      }
    }

    if ([zeek_ssl][client_issuer]) {
      mutate { id => "mutate_gsub_zeek_ssl_client_issuer"
               gsub => [ "[zeek_ssl][client_issuer]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_ssl_client_issuer"
               rename => { "[zeek_ssl][client_issuer]" => "[zeek_ssl][client_issuer_full]" } }
      kv {
        id => "mutate_kv_zeek_ssl_client_issuer"
        field_split => ","
        source => "[zeek_ssl][client_issuer_full]"
        target => "[zeek_ssl][client_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_issuer"
        field => "[zeek_ssl][client_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_ssl_client_issuer_full"
        field => "[zeek_ssl][client_issuer_full]"
      }
    }

    if ([zeek_ssl][ssl_version]) {
      mutate { id => "mutate_merge_zeek_ssl_version"
               merge => { "[tls][version]" => "[zeek_ssl][ssl_version]" } }
      ruby {
        id => "ruby_zeek_ssl_versionCnt"
        code => "event.set('[tls][versionCnt]', event.get('[tls][version]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_tls_versionCnt"
        convert_datatype => {
          "[tls][versionCnt]" => "int"
        }
      }
    }

    if ([zeek_ssl][cipher]) {
      mutate { id => "mutate_merge_zeek_ssl_cipher"
               merge => { "[tls][cipher]" => "[zeek_ssl][cipher]" } }
      ruby {
        id => "ruby_zeek_ssl_cipherCnt"
        code => "event.set('[tls][cipherCnt]', event.get('[tls][cipher]').length)"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_tls_cipherCnt"
        convert_datatype => {
          "[tls][cipherCnt]" => "int"
        }
      }
    }

    if ([zeek_ssl][ja3]) {
      mutate { id => "mutate_merge_zeek_ssl_ja3"
               merge => { "[tls][ja3]" => "[zeek_ssl][ja3]" } }
      mutate { id => "mutate_add_field_zeek_ssl_ja3Cnt"
               add_field => { "[tls][ja3Cnt]" => "1" } }
      dissect {
        id => "dissect_convert_datatype_zeek_tls_ssl_ja3Cnt"
        convert_datatype => {
          "[tls][ja3Cnt]" => "int"
        }
      }
      translate {
        id => "translate_zeek_ssl_ja3"
        field => "[zeek_ssl][ja3]"
        destination => "[zeek_ssl][ja3_desc]"
        dictionary_path => "/etc/ja3.yaml"
      }
    }

    if ([zeek_ssl][ja3s]) {
      mutate { id => "mutate_merge_zeek_ssl_ja3s"
               merge => { "[tls][ja3s]" => "[zeek_ssl][ja3s]" } }
      mutate { id => "mutate_add_field_zeek_ssl_ja3sCnt"
               add_field => { "[tls][ja3sCnt]" => "1" } }
      dissect {
        id => "dissect_convert_datatype_zeek_tls_ssl_ja3sCnt"
        convert_datatype => {
          "[tls][ja3sCnt]" => "int"
        }
      }
      translate {
        id => "translate_zeek_ssl_ja3s"
        field => "[zeek_ssl][ja3s]"
        destination => "[zeek_ssl][ja3s_desc]"
        dictionary_path => "/etc/ja3.yaml"
      }
    }

    # collect all FUIDs under the parent [zeek][fuid] array
    if ([zeek_ssl][cert_chain_fuids]) {
      mutate { id => "mutate_split_zeek_ssl_cert_chain_fuids"
               split => { "[zeek_ssl][cert_chain_fuids]" => "," } }
      mutate { id => "mutate_merge_zeek_ssl_cert_chain_fuids"
               merge => { "[@metadata][cert_fuids]" => "[cert_chain_fuids]" } }
    }
    if ([zeek_ssl][client_cert_chain_fuids]) {
      mutate { id => "mutate_split_zeek_ssl_client_cert_chain_fuids"
               split => { "[zeek_ssl][client_cert_chain_fuids]" => "," } }
      mutate { id => "mutate_merge_zeek_ssl_client_cert_chain_fuids"
               merge => { "[@metadata][cert_fuids]" => "[zeek_ssl][client_cert_chain_fuids]" } }
    }
    if ([@metadata][cert_fuids]) {
      mutate { id => "mutate_merge_zeek_ssl_fuids_to_fuid"
               merge => { "[zeek][fuid]" => "[@metadata][cert_fuids]" } }
    }

  } else if ([source] == "x509") {
    #############################################################################################################################
    # x509.log specific logic

    # split subject/issuer out into hashes
    # 1. handle escaped commans (urlencode)
    # 2. rename source hashes into metadata for splitting
    # 3. split fields by comma into destination hashes
    # 4. urldecode any commas we might have had

    if ([zeek_x509][certificate_subject]) {
      mutate { id => "mutate_gsub_zeek_x509_certificate_subject"
               gsub => [ "[zeek_x509][certificate_subject]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_x509_certificate_subject"
               rename => { "[zeek_x509][certificate_subject]" => "[zeek_x509][certificate_subject_full]" } }
      kv {
        id => "mutate_kv_zeek_x509_certificate_subject"
        field_split => ","
        source => "[zeek_x509][certificate_subject_full]"
        target => "[zeek_x509][certificate_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_subject"
        field => "[zeek_x509][certificate_subject]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_subject_full"
        field => "[zeek_x509][certificate_subject_full]"
      }
      if ([zeek_x509][certificate_subject][CN]) {
        mutate { id => "mutate_merge_zeek_x509_certificate_subject_CN"
                 merge => { "[@metadata][cert][subjectCN]" => "[zeek_x509][certificate_subject][CN]" } }
      }
      if ([zeek_x509][certificate_subject][O]) {
        mutate { id => "mutate_add_zeek_x509_certificate_subject_O"
                 add_field => { "[@metadata][cert][subjectON]" => "%{[zeek_x509][certificate_subject][O]}" } }
      }
    }

    if ([zeek_x509][certificate_issuer]) {
      mutate { id => "mutate_gsub_zeek_x509_certificate_issuer"
               gsub => [ "[zeek_x509][certificate_issuer]", "\\\\,", "%2C" ] }
      mutate { id => "mutate_rename_zeek_x509_certificate_issuer"
               rename => { "[zeek_x509][certificate_issuer]" => "[zeek_x509][certificate_issuer_full]" } }
      kv {
        id => "mutate_kv_zeek_x509_certificate_issuer"
        field_split => ","
        source => "[zeek_x509][certificate_issuer_full]"
        target => "[zeek_x509][certificate_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_issuer"
        field => "[zeek_x509][certificate_issuer]"
      }
      urldecode {
        id => "mutate_urldecode_zeek_x509_certificate_issuer_full"
        field => "[zeek_x509][certificate_issuer_full]"
      }
      if ([zeek_x509][certificate_issuer][CN]) {
        mutate { id => "mutate_merge_zeek_x509_certificate_issuer_CN"
                 merge => { "[@metadata][cert][issuerCN]" => "[zeek_x509][certificate_issuer][CN]" } }
      }
      if ([zeek_x509][certificate_issuer][O]) {
        mutate { id => "mutate_add_zeek_x509_certificate_issuer_O"
                 add_field => { "[@metadata][cert][issuerON]" => "%{[zeek_x509][certificate_issuer][O]}" } }
      }
    }

    if ([zeek_x509][certificate_not_valid_before]) and ([zeek_x509][certificate_not_valid_after]) {
      ruby {
        id => "ruby_zeek_x509_valid_range"
        code => "event.set('[@metadata][cert][notBefore]', (1000*event.get('[zeek_x509][certificate_not_valid_before]').to_f).round(0))
                 event.set('[@metadata][cert][notAfter]', (1000*event.get('[zeek_x509][certificate_not_valid_after]').to_f).round(0))
                 event.set('[@metadata][cert][validDays]', ((event.get('[zeek_x509][certificate_not_valid_after]').to_f - event.get('[zeek_x509][certificate_not_valid_before]').to_f)/(24.0*60.0*60.0)).round(0))"
      }
      dissect {
        id => "dissect_convert_datatype_zeek_x509_time_range"
        convert_datatype => {
          "[@metadata][cert][notBefore]" => "int"
          "[@metadata][cert][notAfter]" => "int"
          "[@metadata][cert][validDays]" => "float"
        }
      }

      date {
        id => "date_zeek_x509_before"
        match => [ "[zeek_x509][certificate_not_valid_before]", "UNIX" ]
        target => "[@metadata][x509_before]"
      }
      if ([@metadata][x509_before]) { mutate { id => "mutate_replace_zeek_x509_before"
                                         replace => { "[zeek_x509][certificate_not_valid_before]" => "%{[@metadata][x509_before]}" } } }

      date {
        id => "date_zeek_x509_after"
        match => [ "[zeek_x509][certificate_not_valid_after]", "UNIX" ]
        target => "[@metadata][x509_after]"
      }
      if ([@metadata][x509_after]) { mutate { id => "mutate_replace_zeek_x509_after"
                                       replace => { "[zeek_x509][certificate_not_valid_after]" => "%{[@metadata][x509_after]}" } } }
    }

    if ([zeek_x509][certificate_serial]) {
      # todo: serial not showing up right...
      # ruby {
      #  id => "ruby_zeek_x509_serial"
      #  code => "event.set('[@metadata][cert][serial]', event.get('[certificate_serial]').unpack('C*').map {|e| e.to_s 16}.join(':'))"
      # }
      mutate { id => "mutate_add_field_zeek_x509_serial"
               add_field => { "[@metadata][cert][serial]" => "%{[zeek_x509][certificate_serial]}" } }
    }

    if ([@metadata][cert]) {
      ruby {
          id => "ruby_zeek_x509_cert_array_set"
          code => "
              certArray = Array.new
              certArray.push(event.get('[@metadata][cert]'))
              event.set('[cert]', certArray)"
      }
    }

    # collect all FUIDs under the parent [zeek][fuid] array
    if ([zeek_x509][fuid]) {
      mutate { id => "mutate_split_zeek_x509_fuid"
               split => { "[zeek_x509][fuid]" => "," } }
      mutate { id => "mutate_merge_zeek_x509_fuid"
               merge => { "[zeek][fuid]" => "[zeek_x509][fuid]" } }
    }

  } # end if/else if/else for specific log type logic
  #######################################################################################################

  # get counts for some arrays that each log type may contribute to individually

  if ([protocol]) {
    ruby {
      id => "ruby_zeek_protocolCnt"
      code => "event.set('[protocolCnt]', event.get('[protocol]').length)"
    }
  }

  if ([user]) {
    ruby {
      id => "ruby_zeek_userCnt"
      code => "event.set('[userCnt]', event.get('[user]').length)"
    }
  }

  mutate {
    id => "mutate_remove_field_zeek_useless"
    remove_field => [
      "[beat]",
      "[offset]",
      "[prospector]",
      "[message]"
    ]
  }

  # this identifies which node the log came from
  if ([host][name]) {
    mutate { id => "mutate_add_field_host_name_node"
             add_field => { "[node]" => "%{[host][name]}" } }
  } else {
    mutate { id => "mutate_add_field_zeek_node"
             add_field => { "[node]" => "zeek" } }
  }

  mutate { id => "mutate_rename_zeek_logType"
           rename => { "[source]" => "[zeek][logType]" } }

  # set data types for fields that belong to multiple types of logs
  if ([totBytes]) {
    dissect {
      id => "dissect_convert_datatype_zeek_totBytes"
      convert_datatype => {
        "[totBytes]" => "int"
      }
    }
  }

  if ([srcBytes]) {
    dissect {
      id => "dissect_convert_datatype_zeek_srcBytes"
      convert_datatype => {
        "[srcBytes]" => "int"
      }
    }
  }

  if ([dstBytes]) {
    dissect {
      id => "dissect_convert_datatype_zeek_dstBytes"
      convert_datatype => {
        "[dstBytes]" => "int"
      }
    }
  }

  if ([totDataBytes]) {
    dissect {
      id => "dissect_convert_datatype_zeek_totDataBytes"
      convert_datatype => {
        "[totDataBytes]" => "int"
      }
    }
  }

  if ([srcDataBytes]) {
    dissect {
      id => "dissect_convert_datatype_zeek_srcDataBytes"
      convert_datatype => {
        "[srcDataBytes]" => "int"
      }
    }
  }

  if ([dstDataBytes]) {
    dissect {
      id => "dissect_convert_datatype_zeek_dstDataBytes"
      convert_datatype => {
        "[dstDataBytes]" => "int"
      }
    }
  }

  if ([totPackets]) {
    dissect {
      id => "dissect_convert_datatype_zeek_totPackets"
      convert_datatype => {
        "[totPackets]" => "int"
      }
    }
  }

  if ([srcPackets]) {
    dissect {
      id => "dissect_convert_datatype_zeek_srcPackets"
      convert_datatype => {
        "[srcPackets]" => "int"
      }
    }
  }

  if ([dstPackets]) {
    dissect {
      id => "dissect_convert_datatype_zeek_dstPackets"
      convert_datatype => {
        "[dstPackets]" => "int"
      }
    }
  }

  if ([srcPort]) {
    dissect {
      id => "dissect_convert_datatype_zeek_srcPort"
      convert_datatype => {
        "[srcPort]" => "int"
      }
    }
  }

  if ([dstPort]) {
    dissect {
      id => "dissect_convert_datatype_zeek_dstPort"
      convert_datatype => {
        "[dstPort]" => "int"
      }
    }
  }

  if ([length]) {
    dissect {
      id => "dissect_convert_datatype_zeek_length"
      convert_datatype => {
        "[length]" => "int"
      }
    }
  }

  if ([timestamp]) {
    dissect {
      id => "dissect_convert_datatype_zeek_timestamp"
      convert_datatype => {
        "[timestamp]" => "int"
      }
    }
  }

  if ([firstPacket]) {
    dissect {
      id => "dissect_convert_datatype_zeek_firstPacket"
      convert_datatype => {
        "[firstPacket]" => "int"
      }
    }
  }

  if ([lastPacket]) {
    dissect {
      id => "dissect_convert_datatype_zeek_lastPacket"
      convert_datatype => {
        "[lastPacket]" => "int"
      }
    }
  }

  if ([protocolCnt]) {
    dissect {
      id => "dissect_convert_datatype_zeek_protocolCnt"
      convert_datatype => {
        "[protocolCnt]" => "int"
      }
    }
  }

  if ([ipProtocol]) {
    dissect {
      id => "dissect_convert_datatype_zeek_ipProtocol"
      convert_datatype => {
        "[ipProtocol]" => "int"
      }
    }
  }

  if ([userCnt]) {
    dissect {
      id => "dissect_convert_datatype_zeek_userCnt"
      convert_datatype => {
        "[userCnt]" => "int"
      }
    }
  }

  if ([zeek][fuidCnt]) {
    dissect {
      id => "dissect_convert_datatype_zeek_fuidCnt"
      convert_datatype => {
        "[zeek][fuidCnt]" => "int"
      }
    }
  }

  if ([zeek][filenameCnt]) {
    dissect {
      id => "dissect_convert_datatype_zeek_filenameCnt"
      convert_datatype => {
        "[zeek][filenameCnt]" => "int"
      }
    }
  }

  if ([zeek][filetypeCnt]) {
    dissect {
      id => "dissect_convert_datatype_zeek_filetypeCnt"
      convert_datatype => {
        "[zeek][filetypeCnt]" => "int"
      }
    }
  }

} # end Filter

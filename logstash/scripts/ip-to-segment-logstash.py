#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Copyright (c) 2023 Battelle Energy Alliance, LLC.  All rights reserved.

import sys
import os
import re
import argparse
import struct
import ipaddress
import itertools
import json
import pprint
import uuid
from collections import defaultdict

UNSPECIFIED_TAG = '<~<~<none>~>~>'
DEVICE_LIST_IDX = 0
SEGMENT_LIST_IDX = 1

JSON_MAP_TYPE_SEGMENT = 'segment'
JSON_MAP_TYPE_DEVICE = 'host'
JSON_MAP_KEY_ADDR = 'address'
JSON_MAP_KEY_NAME = 'name'
JSON_MAP_KEY_TAG = 'tag'
JSON_MAP_KEY_TYPE = 'type'

###################################################################################################
# print to stderr
def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


###################################################################################################
# convenient boolean argument parsing
def str2bool(v):
    if v.lower() in ('yes', 'true', 't', 'y', '1'):
        return True
    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
        return False
    else:
        raise argparse.ArgumentTypeError('Boolean value expected.')


###################################################################################################
# main
def main():

    # extract arguments from the command line
    # print (sys.argv[1:]);
    parser = argparse.ArgumentParser(
        description='Logstash IP address to Segment Filter Creator',
        add_help=False,
        usage='ip-to-segment-logstash.py <arguments>',
    )
    parser.add_argument(
        '-i',
        '--input',
        dest='jsonInput',
        metavar='<STR>',
        type=str,
        nargs='*',
        default='',
        help='JSON network mapping file(s)',
    )
    parser.add_argument(
        '-o',
        '--output',
        dest='output',
        metavar='<STR>',
        type=str,
        default='-',
        help='Output file',
    )
    parser.add_argument(
        '-t',
        '--tags',
        dest='tagChecking',
        type=str2bool,
        nargs='?',
        const=True,
        default=False,
        help=f"Generate check for required tags based on {JSON_MAP_KEY_TAG} attribute",
    )
    try:
        parser.error = parser.exit
        args = parser.parse_args()
    except SystemExit:
        parser.print_help()
        exit(2)

    # read each input file into its own list
    mixedEntries = []

    for inFile in args.jsonInput:
        try:
            tmpMixedEntries = json.load(open(inFile, 'r'))
            if isinstance(tmpMixedEntries, list):
                mixedEntries.extend(tmpMixedEntries)
        except:
            pass

    if len(mixedEntries) > 0:

        filterId = 0
        addedFields = set()

        outFile = open(args.output, 'w+') if (args.output and args.output != '-') else sys.stdout
        try:
            print('filter {', file=outFile)
            print("", file=outFile)
            print("  # this file was automatically generated by {}".format(os.path.basename(__file__)), file=outFile)
            print("", file=outFile)

            # process segment mappings into a dictionary of two dictionaries of lists (one for devices, one for segments)
            # eg., tagListMap[required tag name][DEVICE_LIST_IDX|SEGMENT_LIST_IDX][network segment name] = [172.16.0.0/12, 192.168.0.0/24, 10.0.0.41]
            tagListMap = defaultdict(lambda: [defaultdict(list), defaultdict(list)])

            # handle mixed entries from the JSON-formatted file
            for entry in mixedEntries:

                # the entry must at least contain type, address, name; may optionally contain tag
                if (
                    isinstance(entry, dict)
                    and all(key in entry for key in (JSON_MAP_KEY_TYPE, JSON_MAP_KEY_NAME, JSON_MAP_KEY_ADDR))
                    and entry[JSON_MAP_KEY_TYPE] in (JSON_MAP_TYPE_SEGMENT, JSON_MAP_TYPE_DEVICE)
                    and (len(entry[JSON_MAP_KEY_NAME]) > 0)
                    and (len(entry[JSON_MAP_KEY_ADDR]) > 0)
                ):

                    addressList = []
                    networkList = []

                    tagReq = (
                        entry[JSON_MAP_KEY_TAG]
                        if args.tagChecking and (JSON_MAP_KEY_TAG in entry) and (len(entry[JSON_MAP_KEY_TAG]) > 0)
                        else UNSPECIFIED_TAG
                    )

                    # account for comma-separated multiple addresses per 'address' value
                    for addr in ''.join(entry[JSON_MAP_KEY_ADDR].split()).split(','):

                        if entry[JSON_MAP_KEY_TYPE] == JSON_MAP_TYPE_SEGMENT:
                            # potentially interpret address as a CIDR-formatted subnet
                            try:
                                networkList.append(
                                    str(ipaddress.ip_network(addr)).lower()
                                    if ('/' in addr)
                                    else str(ipaddress.ip_address(addr)).lower()
                                )
                            except ValueError:
                                eprint('"{}" is not a valid IP address, ignoring'.format(addr))

                        else:
                            # should be an IP or MAC address
                            try:
                                # see if it's an IP address
                                addressList.append(str(ipaddress.ip_address(addr)).lower())
                            except ValueError:
                                # see if it's a MAC address
                                if re.match(macAddrRegex, addr):
                                    # prepend _ temporarily to distinguish a mac address
                                    addressList.append("_{}".format(addr.replace('-', ':').lower()))
                                else:
                                    eprint('"{}" is not a valid IP or MAC address, ignoring'.format(ip))

                    if len(networkList) > 0:
                        tagListMap[tagReq][SEGMENT_LIST_IDX][entry[JSON_MAP_KEY_NAME]].extend(networkList)

                    if len(addressList) > 0:
                        tagListMap[tagReq][DEVICE_LIST_IDX][entry[JSON_MAP_KEY_NAME]].extend(addressList)

            # go through the lists of segments/devices, which will now be organized by required tag first, then
            # segment/device name, then the list of addresses
            for tag, nameMaps in tagListMap.items():
                print("", file=outFile)

                # if a tag name is specified, print the IF statement verifying the tag's presence
                if tag != UNSPECIFIED_TAG:
                    print('  if ("{}" in [tags]) {{'.format(tag), file=outFile)
                try:

                    # for the device(s) to be checked, create two filters, one for source IP|MAC and one for dest IP|MAC
                    for device, addrList in nameMaps[DEVICE_LIST_IDX].items():

                        # ip addresses mapped to device
                        ipList = list(set([a for a in addrList if not a.startswith('_')]))
                        if len(ipList) >= 1:
                            for source in ['source', 'destination']:
                                filterId += 1
                                newFieldName = "".join([f"[{x}]" for x in [source, "device", "name"]])
                                print("", file=outFile)
                                print(
                                    '    if ([{}][ip]) and ({}) {{ '.format(
                                        source, ' or '.join(['([{}][ip] == "{}")'.format(source, ip) for ip in ipList])
                                    ),
                                    file=outFile,
                                )
                                print(
                                    '      mutate {{ id => "mutate_add_autogen_{}_ip_device_{}"'.format(
                                        source, filterId
                                    ),
                                    file=outFile,
                                )
                                print(
                                    '        add_field => {{ "{}" => "{}" }}'.format(newFieldName, device),
                                    file=outFile,
                                )
                                print("      }", file=outFile)
                                print("    }", file=outFile)
                                addedFields.add(newFieldName)

                        # mac addresses mapped to device
                        macList = list(set([a for a in addrList if a.startswith('_')]))
                        if len(macList) >= 1:
                            for source in ['source', 'destination']:
                                filterId += 1
                                newFieldName = "".join([f"[{x}]" for x in [source, "device", "name"]])
                                print("", file=outFile)
                                print(
                                    '    if ([{}][mac]) and ({}) {{ '.format(
                                        source,
                                        ' or '.join(['([{}][mac] == "{}")'.format(source, mac[1:]) for mac in macList]),
                                    ),
                                    file=outFile,
                                )
                                print(
                                    '      mutate {{ id => "mutate_add_autogen_{}_mac_device_{}"'.format(
                                        source, filterId
                                    ),
                                    file=outFile,
                                )
                                print(
                                    '        add_field => {{ "{}" => "{}" }}'.format(newFieldName, device),
                                    file=outFile,
                                )
                                print("      }", file=outFile)
                                print("    }", file=outFile)
                                addedFields.add(newFieldName)

                    # for the segment(s) to be checked, create two cidr filters, one for source IP and one for dest IP
                    for segmentName, ipList in nameMaps[SEGMENT_LIST_IDX].items():
                        ipList = list(set(ipList))
                        for source in ['source', 'destination']:
                            filterId += 1
                            # ip addresses/ranges mapped to network segment names
                            newFieldName = "".join([f"[{x}]" for x in [source, "segment", "name"]])
                            print("", file=outFile)
                            print("    if ([{}][ip]) {{ cidr {{".format(source), file=outFile)
                            print('      id => "cidr_autogen_{}_segment_{}"'.format(source, filterId), file=outFile)
                            print('      address => [ "%{{[{}][ip]}}" ]'.format(source), file=outFile)
                            print(
                                '      network => [ {} ]'.format(', '.join('"{}"'.format(ip) for ip in ipList)),
                                file=outFile,
                            )
                            print(
                                '      add_field => {{ "{}" => "{}" }}'.format(newFieldName, segmentName), file=outFile
                            )
                            print("    } }", file=outFile)
                            addedFields.add("{}".format(newFieldName))

                finally:
                    # if a tag name is specified, close the IF statement verifying the tag's presence
                    if tag != UNSPECIFIED_TAG:
                        print("", file=outFile)
                        print('  }} # end (if "{}" in [tags])'.format(tag), file=outFile)

        finally:
            # deduplicate any added fields
            if addedFields:
                print("", file=outFile)
                print('  # deduplicate any added fields', file=outFile)
                for field in list(itertools.product(['source', 'destination'], ['device', 'segment'], ['name'])):
                    newFieldName = "".join([f"[{x}]" for x in [field[0], field[1], field[2]]])
                    if newFieldName in addedFields:
                        print("", file=outFile)
                        print('  if ({}) {{ '.format(newFieldName), file=outFile)
                        print(
                            '    ruby {{ id => "ruby{}deduplicate"'.format(
                                ''.join(c for c, _ in itertools.groupby(re.sub('[^0-9a-zA-Z]+', '_', newFieldName)))
                            ),
                            file=outFile,
                        )
                        print('      code => "', file=outFile)
                        print("        fieldVals = event.get('{}')".format(newFieldName), file=outFile)
                        print(
                            "        if fieldVals.kind_of?(Array) then event.set('{}', fieldVals.uniq) end".format(
                                newFieldName
                            ),
                            file=outFile,
                        )
                        print('      "', file=outFile)
                        print('  } }', file=outFile)

            # close out filter with ending }
            print("", file=outFile)
            print('} # end Filter', file=outFile)

        if outFile is not sys.stdout:
            outFile.close()


if __name__ == '__main__':
    main()

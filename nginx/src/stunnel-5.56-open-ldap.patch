diff -Nurp a/src/protocol.c b/src/protocol.c
--- a/src/protocol.c	2019-05-15 13:35:16.000000000 -0600
+++ b/src/protocol.c	2019-12-03 08:39:18.942831089 -0700
@@ -64,6 +64,7 @@ NOEXPORT char *pop3_server(CLI *, SERVIC
 NOEXPORT char *imap_client(CLI *, SERVICE_OPTIONS *, const PHASE);
 NOEXPORT char *imap_server(CLI *, SERVICE_OPTIONS *, const PHASE);
 NOEXPORT char *nntp_client(CLI *, SERVICE_OPTIONS *, const PHASE);
+NOEXPORT char *openldap_client(CLI *, SERVICE_OPTIONS *, const PHASE);
 NOEXPORT char *connect_server(CLI *, SERVICE_OPTIONS *, const PHASE);
 NOEXPORT char *connect_client(CLI *, SERVICE_OPTIONS *, const PHASE);
 #ifndef OPENSSL_NO_MD4
@@ -113,6 +114,10 @@ char *protocol(CLI *c, SERVICE_OPTIONS *
         return opt->option.client ?
             nntp_client(c, opt, phase) :
             "The 'nntp' protocol is not supported in the server mode";
+    if(!strcasecmp(opt->protocol, "openldap"))
+        return opt->option.client ?
+            openldap_client(c, opt, phase) :
+            "The 'openldap' protocol is not supported in the server mode";
     if(!strcasecmp(opt->protocol, "connect"))
         return opt->option.client ?
             connect_client(c, opt, phase) :
@@ -1119,6 +1124,89 @@ NOEXPORT char *nntp_client(CLI *c, SERVI
     return NULL;
 }
 
+/**************************************** LDAP, RFC 2830 */
+uint8_t ldap_startssl_message[0x1d + 2] =
+{
+  0x30,        /* tag = UNIVERSAL SEQUENCE */
+  0x1d,        /* len = 29 (the remaining number of bytes in this message) */
+  0x02,        /*   messageID */
+  0x01,        /*   len = 1 */
+  0x01,        /*   value = 1 (this is messageID 1) */
+               /*   --- */
+  0x77,        /*   protocolOp = APPLICATION (23) (=ExtendedRequest)
+                 *     0b01xxxxxx => APPLICATION
+                 *     0bxx1xxxxx => ?
+                 *     0xxxx10111 => 23
+               */
+  0x18,        /*   len = 24 */
+  0x80,        /*   type = requstName? */
+  0x16,        /*   len = 22 */
+  /* OID: 1.3.6.1.4.1.1466.20037 (=LDAP_START_TLS_OID)*/
+  '1', '.',
+  '3', '.',
+  '6', '.',
+  '1', '.',
+  '4', '.',
+  '1', '.',
+  '1', '4', '6', '6', '.',
+  '2', '0', '0', '3', '7'
+  /* No requestValue, as per RFC2830 (in 2.1: "The requestValue field is absent") */
+};
+
+NOEXPORT char *openldap_client(CLI *c, SERVICE_OPTIONS *opt, const PHASE phase) {
+
+    uint8_t buffer[1];
+    uint8_t ldap_response[256];
+
+    s_log(LOG_DEBUG, "Requesting LDAP Start TLS");
+    s_write(c, c->remote_fd.fd, ldap_startssl_message, (size_t)ldap_startssl_message[1] + 2);
+
+    s_read(c, c->remote_fd.fd, buffer, 1);
+    if(buffer[0] != 0x30) {
+        s_log(LOG_ERR, "start tag is not UNIVERSAL SEQUENCE");
+        throw_exception(c, 1);
+    }
+
+    s_log(LOG_DEBUG, "Reading LDAP message size (1 byte).");
+    s_read(c, c->remote_fd.fd, buffer, 1);
+
+    s_log(LOG_DEBUG, "Reading LDAP message (%u byte(s))", buffer[0]);
+    s_read(c, c->remote_fd.fd, ldap_response, buffer[0]);
+
+    if(ldap_response[0] != 0x02) {
+        s_log(LOG_ERR, "LDAP response does not start with type messageID");
+        throw_exception(c, 1);
+    }
+    if(ldap_response[1] != 0x01) {
+        s_log(LOG_ERR, "This is not an extendedResp(1)");
+        throw_exception(c, 1);
+    }
+    if(ldap_response[2] != 0x01) {
+        s_log(LOG_ERR, "Non-matching messageID");
+        throw_exception(c, 1);
+    }
+    if(ldap_response[3] != 0x78) {
+        s_log(LOG_ERR, "This is not a protocolOp for APPLICATION ExtendedResponse");
+        throw_exception(c, 1);
+    }
+    if(ldap_response[4] != 0x07) {
+        s_log(LOG_ERR, "Expected 0x07 indicating extendedResp is 7 bytes long");
+        throw_exception(c, 1);
+    }
+    if(ldap_response[5] != 0x0a) {
+        s_log(LOG_ERR, "This is not an extendedResp");
+        throw_exception(c, 1);
+    }
+    if(ldap_response[6] != 0x01) {
+        s_log(LOG_ERR, "This is not an extendedResp");
+        throw_exception(c, 1);
+    }
+    if(ldap_response[7] != 0x00) {
+        s_log(LOG_ERR, "This is not resultCode success");
+        throw_exception(c, 1);
+    }
+}
+
 /**************************************** connect */
 
 NOEXPORT char *connect_server(CLI *c, SERVICE_OPTIONS *opt, const PHASE phase) {
